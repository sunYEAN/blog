<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cocos creator 学习记录</title>
      <link href="/Blog/2020/07/28/2020-07-28/"/>
      <url>/Blog/2020/07/28/2020-07-28/</url>
      
        <content type="html"><![CDATA[<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li>onLoad // 脚本初始化阶段，场景被载入时触发</li><li>start // 会在第一次执行update之前触发</li><li>update // 每一帧的回调，会在所有动画更新之前执行</li><li>lateUpdate // 动效更新完毕之后执行</li><li>onDestroy // 对应onLoad，与onLoad成对调用</li><li>onEnable  // 组件的enabled属性从false变为true时</li><li>onDisable // 组件的enabled属性从true变为false时</li></ul><p>一个组价的完整生命周期 -&gt; onLoad -&gt; onEnable -&gt; start -&gt; update -&gt; lateUpdate -&gt; onDisable -&gt; onDestroy</p><h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据需要JSON.stringify和parse</span></span><br><span class="line">cc.sys.localStorage.setItem(name, value);</span><br><span class="line">cc.sys.localStorage.getItem(name);</span><br><span class="line">cc.sys.localStorage.removeItem(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getLocalStorage = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> value = cc.sys.localStorage.getItem(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(value);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setLocalStorage = <span class="function"><span class="keyword">function</span> (<span class="params">name, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">"object"</span>) &#123; </span><br><span class="line">        value = <span class="built_in">JSON</span>.stringify(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cc.sys.localStorage.setItem(name, value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> removeLocalStorage = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cc.sys.localStorage.removeItem(name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据本地存储可以通过ncryptjs加密一下，可以缓解游戏被破解的时间。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 抖音小游戏 </tag>
            
            <tag> cocos creator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型</title>
      <link href="/Blog/2020/07/20/2020-07-20-1/"/>
      <url>/Blog/2020/07/20/2020-07-20-1/</url>
      
        <content type="html"><![CDATA[<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'TT'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个函数都有一个prototype属性，</span></span><br><span class="line"><span class="comment">// 该属性指向了一个对象，这个对象是（通过调用该构造函数而创建的实例的 —— p）原型，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个实例都会从原型“继承”属性，</span></span><br><span class="line"><span class="comment">// 每个实例化的对象都会有一个“__proto__”的属性，</span></span><br><span class="line"><span class="comment">// 该属性指向该实例的原型 也就是 Person的prototype。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们知道，对象都有自己的原型，既然Person.prototype是一个对象，那么它的原型是什么呢？</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 Object的原型指向是null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><img data-src="https://source.mnnuu.cn/websources/blog/2020-07-20/prototype.png" alt="文件结构"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript深入</title>
      <link href="/Blog/2020/07/20/2020-07-20-2/"/>
      <url>/Blog/2020/07/20/2020-07-20-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作用域是指程序源代码中定义变量的区域。作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p></blockquote><p>JavaScript 是词法作用域，在编译阶段(JS执行过程分为编译阶段、执行阶段)的时候作用域就确定了。</p><h2 id="JavaScript的执行过程"><a href="#JavaScript的执行过程" class="headerlink" title="JavaScript的执行过程"></a>JavaScript的执行过程</h2><h3 id="一、编译阶段"><a href="#一、编译阶段" class="headerlink" title="一、编译阶段"></a>一、编译阶段</h3><p>当执行JavaScript之前编译器会先对js代码进行词法分析、然后生成可执行代码，并确定作用域。</p><h3 id="二、执行阶段"><a href="#二、执行阶段" class="headerlink" title="二、执行阶段"></a>二、执行阶段</h3><p><strong>执行上下文 和 执行上下文栈</strong><br>当JS引擎执行每一段可执行代码的时候，会创建对应的<strong>执行上下文</strong>。而<strong>执行上下文栈</strong>是JS引擎创建来管理执行上下文的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECSTACK = [ globalContext ]</span><br></pre></td></tr></table></figure><p>JavaScript引擎执行js代码的时候，最先遇到的是全局代码，所以初始化 <strong>“执行上下文栈”</strong> 的时候会先向其压入一个 <strong>“全局执行上下文”</strong>，并且只有当应用程序结束的时候才会清空。所以栈底永远有一个 <strong>“全局执行上下文”</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 看代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'fun3'</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123; fun3() &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123; fun2() &#125;</span><br><span class="line">fun1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码展示执行过程</span></span><br><span class="line">ECSTACK.push(<span class="xml"><span class="tag">&lt;<span class="name">fun1</span>&gt;</span> functionContext);</span></span><br><span class="line"><span class="xml">// func1 中执行了 fun2 创建fun2的执行上下文并压入执行栈中</span></span><br><span class="line">ECSTACK.push(&lt;fun2&gt; functionContext);</span><br><span class="line">// 执行fun2代码，执行了 fun3 创建fun3的执行上下文并压入执行栈</span><br><span class="line">ECSTACK.push(&lt;fun3&gt; functionContext);</span><br><span class="line"></span><br><span class="line">// fun3 执行完毕</span><br><span class="line">ECSTACK.pop();</span><br><span class="line">// fun2 执行完毕</span><br><span class="line">ECSTACK.pop();</span><br><span class="line">// fun1 执行完毕</span><br><span class="line">ECSTACK.pop();</span><br></pre></td></tr></table></figure><p><strong>对于每个执行上下文，都可分为两个阶段</strong></p><ul><li><strong>创建阶段</strong><ul><li>创建变量对象（Variable object, VO）</li><li>创建作用域链（Scope chain）</li><li>确定this的指向</li></ul></li><li><strong>执行阶段</strong><ul><li>变量对象激活，变为活动对象。 AO = VO + function parameters + arguments</li></ul></li></ul><h4 id="1、变量对象"><a href="#1、变量对象" class="headerlink" title="1、变量对象"></a>1、变量对象</h4><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。其中全局上下文的变量对象就是全局对象（window）</p><p>创建执行上下文时，</p><p>总结：</p><ul><li>全局上下文的变量对象是全局对象</li><li>函数上下文的变量对象初始化只包括Arguments对象</li><li>进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li><li>在代码执行阶段、会再次修改变量对象的属性值</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算符操作技巧</title>
      <link href="/Blog/2020/07/20/2020-07-20/"/>
      <url>/Blog/2020/07/20/2020-07-20/</url>
      
        <content type="html"><![CDATA[<h3 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h3><p>1、取奇、偶</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按位与</span></span><br><span class="line"><span class="keyword">let</span> odd = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>), (item, index) =&gt; index)</span><br><span class="line">    .filter(<span class="function"><span class="params">number</span> =&gt;</span> number &amp; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(odd);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户授权登录</title>
      <link href="/Blog/2020/07/03/2020-07-03/"/>
      <url>/Blog/2020/07/03/2020-07-03/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在开发小程序的时候，经常会需要获取载体平台（微信、抖音、头条等）用户的信息，通过用户在载体平台的唯一凭证（openid等）来做用户登录。今天来聊一聊具体应该怎么做。</p></blockquote><a id="more"></a><h3 id="小程序流程"><a href="#小程序流程" class="headerlink" title="小程序流程"></a>小程序流程</h3><p>首先通过xx.login()方法获取当前用户的code，服务端拿到我们传过去的code去请求平台服务器，获取到用户的openid，然后在自己的数据库通过该openid创建一个用户，此时用户就已经创建完毕。</p><p>服务器端对该用户做登录操作，并把该用户的基本信息（默认的初始信息）+ token传给前端，前端拿到token。如果要获取该用户的详细信息，调用xx.getUserInfo()方法，这时就需要用户授权（弹出一个面板，提示用户授权，授权完毕才能返回详细信息）<br>后更新到自己数据库中。</p><h3 id="抖音-web-页面-OAuth2-0-授权流程"><a href="#抖音-web-页面-OAuth2-0-授权流程" class="headerlink" title="抖音 web 页面 OAuth2.0 授权流程"></a>抖音 web 页面 OAuth2.0 授权流程</h3><p>1、在应用中发起抖音授权登录请求，抖音用户允许授权第三方应用后（扫码确认或账号密码授权登录），确认通过后，会重定向到第三方网站（回调地址），并附带上code字段。</p><p>2、第三方通过code参数，以及ClientKey、ClientSecret等参数，通过API换取access_token。</p><p>3、通过access_token进行接口调用，获取用户基本信息及其他操作。</p><h4 id="静默授权-（用户无感知）"><a href="#静默授权-（用户无感知）" class="headerlink" title="静默授权 （用户无感知）"></a>静默授权 （用户无感知）</h4><p>通过code获取用户openid来做静默登录。scope=login_id</p><p>####</p><p>用户登录过程</p><h4 id="获取小程序指定页面的二维码"><a href="#获取小程序指定页面的二维码" class="headerlink" title="获取小程序指定页面的二维码"></a>获取小程序指定页面的二维码</h4><p>需要后端通过小程序平台的接口去获取buffer 然后保存到本地将地址给到前端。</p><h4 id="bad-code"><a href="#bad-code" class="headerlink" title="bad code"></a>bad code</h4><p>查看客户端、服务端的appId或者appSecret是否正确</p><h4 id="抖音小程序-上传图片的坑"><a href="#抖音小程序-上传图片的坑" class="headerlink" title="抖音小程序 上传图片的坑"></a>抖音小程序 上传图片的坑</h4><p>今天做了一个抖音小程序上传图片的需求，呕… 呕….</p><p>失态了….</p><p>首先通过tt.chooseImage()方法，获取到图片的本地地址，然后通过tt.uploadFile()上传到我方服务器。</p><p>流程很简单，当我做完测试的时候才发现是我太年轻。</p><p>在手机上测试半天。还以为是白名单没配置，转过来去字节跳动小程序平台又配了一个白名单。</p><p>还不行！！</p><p>还能怎么办，只能一步一步debugger、console出来看看。</p><p>对了，说了这么久，到底是什么问题呢？</p><p>Android端上传没问题，后端该返回的都返回了</p><p>iOS端就比较不一样了，chooseImage的时候返回的templatePath会携带有query，正是这个query导致上传出问题。</p><p><img data-src="https://source.mnnuu.cn/websources/blog/2020-07-03/ios.jpg" alt="ios端"><br>这是ios端通过chooseImage选择的图片的路径</p><p><img data-src="https://source.mnnuu.cn/websources/blog/2020-07-03/android.jpg" alt="android端"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tt.chooseImage(&#123;</span><br><span class="line">  success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> path = res.tempFilePaths[<span class="number">0</span>];</span><br><span class="line">   path = path.split(<span class="string">'?'</span>)[<span class="number">0</span>];</span><br><span class="line">   tt.uploadFile(&#123;</span><br><span class="line">     url: <span class="string">'&#123;&#123;https://xxxx.xxx.xx&#125;&#125;'</span>, <span class="comment">// 目标地址</span></span><br><span class="line">     filePath: path, <span class="comment">// 本地文件路径</span></span><br><span class="line">     name: <span class="string">"&#123;&#123;name&#125;&#125;"</span>, <span class="comment">// 名称</span></span><br><span class="line">     success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(res.data));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>OK 搞定！</p><h4 id="Taro-hook-useEffect最后一次的返回要想执行-得注销页面。"><a href="#Taro-hook-useEffect最后一次的返回要想执行-得注销页面。" class="headerlink" title="Taro hook useEffect最后一次的返回要想执行 得注销页面。"></a>Taro hook useEffect最后一次的返回要想执行 得注销页面。</h4><p>如果自己跳转到自己通过push 页面不会销毁，就不会走。</p><h4 id="小程序开发-域名白名单的坑"><a href="#小程序开发-域名白名单的坑" class="headerlink" title="小程序开发 域名白名单的坑"></a>小程序开发 域名白名单的坑</h4><p>uploadFile需要单独添加</p><h4 id="字节跳动小程序-onHide"><a href="#字节跳动小程序-onHide" class="headerlink" title="字节跳动小程序 onHide"></a>字节跳动小程序 onHide</h4><p>Android 打开激励视频不走onHide，IOS 打开激励视频走了onHide</p><h4 id="抖音分享坑出翔"><a href="#抖音分享坑出翔" class="headerlink" title="抖音分享坑出翔"></a>抖音分享坑出翔</h4><p>怎么说呢，最近沉（入）迷（坑）字节跳动小程序，无法自拔。</p><p>字节跳动小程序，主要包括两个平台（头条、抖音）。目前做字节跳动小程序也是主要针对这两个平台来开发。</p><p>字节跳动的分享接收一个templateId的字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> onShareApp = <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;path, title, desc&#125; = params;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">shareOption</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 视频相关</span></span><br><span class="line">        <span class="keyword">let</span> options = &#123;</span><br><span class="line">            path,</span><br><span class="line">            title,</span><br><span class="line">            success: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 成功回调</span></span><br><span class="line">            &#125;,</span><br><span class="line">            fail: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 失败回调</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">switch</span> (shareOption.channel) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'video'</span>:</span><br><span class="line">                options.channel= <span class="string">"video"</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'share'</span>:</span><br><span class="line">                options.desc= desc;</span><br><span class="line">                options.channel= <span class="string">"share"</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> options;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// options中有一个字段 options.channel 来表示该分享是那种方式的分享</span></span><br><span class="line"><span class="comment">// “video” 表示拍抖音视频分享</span></span><br><span class="line"><span class="comment">// “share” 表示普通分享</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抖音中，拍抖音分享需要申请，且分享文案是templateId中指定的文案。 （templateId在小程序后台中申请）</span></span><br><span class="line"><span class="comment">// 头条中，站内分享可以直接指定文案，站外分享依然需要templateId。</span></span><br><span class="line">onShareAppMessage = onShareApp(&#123;</span><br><span class="line">    desc,</span><br><span class="line">    path,</span><br><span class="line">    title,</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Taro中获取节点信息"><a href="#Taro中获取节点信息" class="headerlink" title="Taro中获取节点信息"></a>Taro中获取节点信息</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过useRef</span></span><br><span class="line"><span class="keyword">const</span> dom = useRef(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// &lt;View ref=&#123;dom&#125;&gt;节点&lt;/View&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过useLayoutEffect这个hooks来获取，因为它会在DOM变更之后同步调用，可以用来读取dom布局</span></span><br><span class="line">useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    dom.boundingClientRect().exec(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> &#123;width, height&#125; = res[<span class="number">0</span>];</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过回调函数的形式来获取 */</span></span><br><span class="line"><span class="keyword">const</span> dom = useCallback(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node);</span><br><span class="line">&#125;, []);</span><br><span class="line"> <span class="comment">// &lt;View ref=&#123;dom&#125;&gt;节点&lt;/View&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Taro激励视频的坑"><a href="#Taro激励视频的坑" class="headerlink" title="Taro激励视频的坑"></a>Taro激励视频的坑</h4><p>Android 打开激励视频不走onHide，IOS 打开激励视频走了onHide,<br>当 A页面 跳转（push）到 A页面时，由于页面不会销毁，所以useEffect最后一次执行是不会走return的函数的，<br>这时只能在onHide里面去执行激励视频的 <strong>offClose</strong> 和 <strong>offError</strong> 的监听，但是ios打开激励视频会走onHide，所以导致ios中，看完激励视频<br> <strong>onClose</strong> 和 <strong>onError</strong> 注册的回调函数被 <strong>offClose</strong> 和 <strong>offError</strong> 销毁掉，这时可以在打开激励视频之后，在通过一个变量改变去触发一次useEffect，<br>再走一遍绑定onClose和onError回调方法。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> VIDEO_AD = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 创建激励视频 */</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (VIDEO_AD) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (Taro.createRewardedVideoAd) &#123;</span><br><span class="line">        VIDEO_AD = Taro.createRewardedVideoAd(&#123;</span><br><span class="line">            adUnitId: <span class="string">'kg61k2lrdpa1gbcdom'</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> success_ad = useCallback(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* 看完广告的回调 */</span></span><br><span class="line">&#125;, [ad_id]);</span><br><span class="line"><span class="keyword">const</span> error_ad = useCallback(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* 广告加载错误的回调 */</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 注册回调函数*/</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// if (!ad_id) return;</span></span><br><span class="line">    <span class="keyword">if</span> (VIDEO_AD) &#123;</span><br><span class="line">        VIDEO_AD.onError(error_ad);</span><br><span class="line">        VIDEO_AD.onClose(success_ad);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (VIDEO_AD) &#123;</span><br><span class="line">            VIDEO_AD.offError(error_ad);</span><br><span class="line">            VIDEO_AD.offClose(success_ad);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [ad_id]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a push a，上面的useEffect最后一次return的函数不会执行</span></span><br><span class="line">useDidHide(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (VIDEO_AD) &#123;</span><br><span class="line">        VIDEO_AD.offError(error_ad);</span><br><span class="line">        VIDEO_AD.offClose(success_ad);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在打开激励视频之后，通过改变ad_id这个字段去再一次的执行useEffect。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. A redirectTo A 则可避免这个问题，也不用在useDidHide中注销回调。</span></span><br></pre></td></tr></table></figure><h4 id="小程序-路由api"><a href="#小程序-路由api" class="headerlink" title="小程序 路由api"></a>小程序 路由api</h4><p>redirectTo(option) 方法会导致页面出现白色闪屏</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-06-29</title>
      <link href="/Blog/2020/06/29/2020-06-29/"/>
      <url>/Blog/2020/06/29/2020-06-29/</url>
      
        <content type="html"><![CDATA[<h2 id="今日坑"><a href="#今日坑" class="headerlink" title="今日坑"></a>今日坑</h2><p>Taro编译bug：css多行省略的属性 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden<span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">-o-text-overflow</span>: ellipsis<span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis<span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box<span class="meta">!important</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 该行属性没有编译到打包文件中，与预期不符 */</span></span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical<span class="meta">!important</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">没有编译到打包文件中，导致省略出错。</span><br><span class="line">解决：</span><br><span class="line"></span><br><span class="line">```<span class="selector-tag">css</span></span><br><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden<span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">-o-text-overflow</span>: ellipsis<span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis<span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box<span class="meta">!important</span>;</span><br><span class="line">  <span class="comment">/*! autoprefixer: ignore next */</span></span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高性能JavaScript之加载和执行</title>
      <link href="/Blog/2020/03/17/2020-03-18/"/>
      <url>/Blog/2020/03/17/2020-03-18/</url>
      
        <content type="html"><![CDATA[<p>因为浏览器的机制，当浏览器解析到script标签的时候，会阻塞进程去下载js代码，并立即执行。</p><p><strong>1、为了加快页面渲染，将script标签添加至</body>之前，当页面渲染完毕之后再去加载js代码。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当script添加在head中时，浏览器解析至此会阻塞整个进程，并等待js加载执行，如果js比较大的话，页面会出现长时间的白屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"a.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"b.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"c.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"a.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"b.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"c.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当我们将script标签移至&lt;/body&gt;之前时，页面会先渲染完毕之后再去下载js代码并执行 --&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>2、给script标签加上defer属性，该属性会指明本元素的脚本不会修改DOM，因此代码能够安全的延迟执行。</strong></p><p>加了defer属性的script标签会立即下载脚本(并行下载)，在window.onLoad执行之前执行其中的代码。<br>带有defer属性的script标签可以放置在文档的任何位置，文件下载时不会阻塞浏览器的其他进程。</p><p><strong>3、动态脚本元素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    script.src = src;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大部分浏览器支持</span></span><br><span class="line">    script.onload = callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兼容IE</span></span><br><span class="line">    script.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (script.readyState === <span class="string">'loaded'</span> || script.readyState === <span class="string">'complete'</span>) &#123;</span><br><span class="line">            script.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">            callback &amp;&amp; callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件将在元素被添加到页面时开始下载，这种方式加载脚本的优点在于：无论在何时启动下载，文件的下载和执行过程都不会阻塞页面的其他进程。</span></span><br><span class="line"><span class="comment">// 使用动态脚本节点下载文件时，返回的代码通常会立即执行（除了Firefox和Opera，它们会等待此前所有动态脚本节点执行完毕）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态注入的script会在被添加到页面时开始下载，</span></span><br><span class="line">        <span class="comment">// 但是不会阻塞页面其他进程，</span></span><br><span class="line">        <span class="comment">// 返回的代码通常会立即执行。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 页面加载完成(window.onLoad)之前加载的script</span></span><br><span class="line">        <span class="comment">// 会在页面加载完成(window.onLoad)之前执行</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VUE SSR 踩坑合集</title>
      <link href="/Blog/2020/03/11/2020-03-11/"/>
      <url>/Blog/2020/03/11/2020-03-11/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p></blockquote><a id="more"></a><h1 id="VUE-服务端渲染（SSR）"><a href="#VUE-服务端渲染（SSR）" class="headerlink" title="VUE 服务端渲染（SSR）"></a>VUE 服务端渲染（SSR）</h1><h2 id="SSR-的优劣势"><a href="#SSR-的优劣势" class="headerlink" title="SSR 的优劣势"></a>SSR 的优劣势</h2><h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul><li>便于SEO</li><li>更快的内容到达时间（避免一进应用就是好几秒的菊花图 ~ ~ )</li></ul><h3 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h3><ul><li>开发条件限制（因为需要在服务器端渲染出html，不能使用window、document等浏览器的属性），浏览器特定的代码只能在某些生命周期钩子函数中使用；一些外部扩展库可能还需要特殊处理才能在服务器渲染应用程序中运行</li><li>涉及项目构建和部署的要求更多</li><li>更多的服务器端负载</li></ul><p>简单介绍了一下Vue服务端渲染，那么服务端渲染打包出来的内容究竟长什么样呢？</p><h3 id="Vue-服务端渲染打包结果"><a href="#Vue-服务端渲染打包结果" class="headerlink" title="Vue 服务端渲染打包结果"></a>Vue 服务端渲染打包结果</h3><p>其中包含两个json文件，还有一些js和html文件 <strong>（静态资源，和普通的浏览器渲染模板打包生成的dist内容一样）</strong> 。我们特别留意一下这两个json文件，它们是Vue服务端渲染比较核心的东西。</p><p><img data-src="http://source.mnnuu.cn/websources/blog/2020-03-11/ssr-vue.png" alt="文件结构"></p><p>既然是服务端渲染，那肯定得开一个node服务来渲染html吧。</p><p><img data-src="http://source.mnnuu.cn/websources/blog/2020-03-11/ssr-vue-server.png" alt="node服务"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// server.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> server = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; createBundleRenderer &#125; = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> template = <span class="built_in">require</span>(<span class="string">'fs'</span>).readFileSync(<span class="string">'./dist/index.client.html'</span>, <span class="string">'utf-8'</span>);</span><br><span class="line"><span class="keyword">const</span> serverBundle = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-server-bundle.json'</span>);</span><br><span class="line"><span class="keyword">const</span> clientManifest = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-client-manifest.json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderer = createBundleRenderer(serverBundle, &#123;</span><br><span class="line">    template,</span><br><span class="line">    clientManifest</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.use(express.static(<span class="string">'./dist'</span>));</span><br><span class="line"></span><br><span class="line">server.get(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> context = &#123; </span><br><span class="line">        url: req.url,</span><br><span class="line">        title: <span class="string">'ssr'</span>,</span><br><span class="line">        meta: <span class="string">`&lt;meta name="viewport" content="width=device-width"&gt;`</span> </span><br><span class="line">    &#125;;</span><br><span class="line">    renderer.renderToString(context, (err, html) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> res.status(<span class="number">500</span>).end(<span class="string">'error: '</span> + err.message)</span><br><span class="line">        res.end(html)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过以上打包后的内容，可以有个比较清晰的方向了。<br>开发后完成后通过 <strong>npm run build</strong> 命令基于 <strong>客户端</strong> 和 <strong>服务端</strong> 两端进行打包，生成 <strong>vue-ssr-client-manifest.json</strong> 文件 和 <strong>vue-ssr-server-bundle.json</strong> 文件。然后在server.js中开启一个服务通过 <strong>vue-server-renderer</strong> 模块中的 <strong>createBundleRenderer()</strong> 方法生成一个renderer对象，在每次浏览器对服务器发起请求的时候，通过调用renderer对象的renderToString方法传入json文件和模板生成html字符串，然后发送给浏览器。</p><p>-.-! then 我们围绕这两个json文件来作文章。</p><p> 先来说下背景，，，最近在看Vue SSR相关知识。参考 vue-ssr 官方 例子，vue-hackernews-2.0，<a href="https://github.com/vuejs/vue-hackernews-2.0" target="_blank" rel="noopener">https://github.com/vuejs/vue-hackernews-2.0</a></p><pre><code>都搞定了后，遇到一个刷新页面的问题（我指的是手动刷新浏览器，不是用router程序刷新），因为程序里router有设置 导航守卫 beforeResolve 用于数据预加载使页面呈现效果。但是，刷新页面后，一直没有响应这个导航守卫。路由配置如下：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="string">'/'</span>: &#123;</span><br><span class="line">    viewpath: <span class="string">'views/homepage'</span>,</span><br><span class="line">    name:<span class="string">'default'</span>,</span><br><span class="line">    title:<span class="string">'首页'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'/hero'</span>: &#123;</span><br><span class="line">    viewpath: <span class="string">'views/hero'</span>,</span><br><span class="line">    name:<span class="string">'hero'</span>,</span><br><span class="line">    title:<span class="string">'英雄'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'/tool'</span>: &#123;</span><br><span class="line">    viewpath: <span class="string">'views/tool'</span>,</span><br><span class="line">    name:<span class="string">'tool'</span>,</span><br><span class="line">    title:<span class="string">'装备'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分别对应三个页面，如下：</span></span><br></pre></td></tr></table></figure><p>（tool页面，手动切换时正常显示的。有图是强刷浏览器，没有响应数据）<br>        咱们先不说在页面create或者mounted做处理。  因为应用程序是打算同时支持vue SSR 和 普通 VUE 程序的，兼容代码写法，不像在vue-cli上客户端加一套逻辑。而且，有守卫导航这个好东西，就是解决这个需求的。</p><pre><code>为甚 beforeResolve 没有生效呢？？？我们来看一下 官方例子的写法，entry-client.js文件，</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeupdate'</span>,to);</span><br><span class="line">    <span class="keyword">const</span> &#123; asyncData &#125; = <span class="keyword">this</span>.$options</span><br><span class="line">    <span class="keyword">if</span> (asyncData) &#123;</span><br><span class="line">      asyncData(&#123;</span><br><span class="line">        store: <span class="keyword">this</span>.$store,</span><br><span class="line">        route: to</span><br><span class="line">      &#125;).then(next).catch(next)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; app, router, store &#125; = createApp()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__INITIAL_STATE__) &#123; </span><br><span class="line">  store.replaceState(<span class="built_in">window</span>.__INITIAL_STATE__)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.onReady(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Add router hook for handling asyncData.</span></span><br><span class="line">  <span class="comment">// Doing it after initial route is resolved so that we don't double-fetch</span></span><br><span class="line">  <span class="comment">// the data that we already have. Using router.beforeResolve() so that all</span></span><br><span class="line">  <span class="comment">// async components are resolved.</span></span><br><span class="line"></span><br><span class="line">  router.beforeResolve(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...这里就是我们想要，预取数据的。</span></span><br><span class="line">        <span class="comment">// 注意到，这个beforeResolve守卫，是在route好了之后才设置的，目的是为了防止服务器已经获取的数据，客户端不用二次获取。  然而，在非ssr应用里，，，我们应该是在router.resolve()之前就应该设置这个导航，不能等页面router解析好了才设置。这就是为什么一刷新页面，没有响应，切换页面时正常的原因所在。</span></span><br><span class="line">        <span class="comment">// 解决办法：把resovle移动到ready函数外面。当然，为了ssr的no double-fetch，，，加一个判断即可。简单的，根据 这个变量 window.__INITIAL_STATE__ 存在来判断即可。因为这个变量就是标志是服务器渲染的页面。</span></span><br></pre></td></tr></table></figure><h2 id="onReady"><a href="#onReady" class="headerlink" title="onReady"></a>onReady</h2><p> 在导航完成初始导航时调用</p><h2 id="beforeEach，beforeResolve"><a href="#beforeEach，beforeResolve" class="headerlink" title="beforeEach，beforeResolve"></a>beforeEach，beforeResolve</h2><p>beforeEach    -&gt; 全局前置守卫：当一个导航触发时，全局前置守卫按照创建顺序调用。<br>beforeResolve -&gt; 全局解析守卫，和beforeEach类似，区别是 在导航被确认之前，同时在所有组件内守卫和异步路由被解析之后被调用</p><p>服务端入口文件(server-entry.js)中, 会根据每个页面请求直接将当前路由设置到router中， asyncData 方法是在路由完成初始导航（onReady）后调用的（防止客户端二次获取相同的数据），然后通过当前路由匹配到的所有组件，依次执行每个组件的asyncData方法<br>客户端入口文件(client-entry.js)中，</p><h3 id="不同的入口文件"><a href="#不同的入口文件" class="headerlink" title="不同的入口文件"></a>不同的入口文件</h3>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack环境构建</title>
      <link href="/Blog/2020/03/09/2020-03-09/"/>
      <url>/Blog/2020/03/09/2020-03-09/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章将教会你手动构建项目环境。</p></blockquote><p>前端自动构建工具从nodejs出现开始，逐渐盛行开。带领WEB前端开发走向了一个自动化、工程化的时代。</p><p>目前WEB前端开发的三大框架都有其脚手架，已经帮助我们完成了webpack的配置，可以让我们注重核心代码的开发。如果我们要根据不同的业务需求，自定义配置文件应该怎么做呢？</p><a id="more"></a><p>首先我们要明确webpack帮助我们做了什么！</p><p>在远古的web开发时代</p><p>转换es6 ++<br>转换jsx<br>css前缀补全<br>压缩混淆<br>图片压缩等</p><p>文件指纹:</p><ul><li>Hash: 和整个项目的构架相关，只要项目文件有修改，整个项目构建hash值就会更改；</li><li>Chunkhash: 和webpack打包的chunk相关，不同的entry会生成不同的chunkhash；</li><li>contenthash：根据文件内容来定义hash，文件内容不变，则contenthash不变；</li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的自定义事件实现（观察者模式）</title>
      <link href="/Blog/2020/03/03/2020-03-03/"/>
      <url>/Blog/2020/03/03/2020-03-03/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在Web开发中，观察者模式随处可见。</p></blockquote><p>web程序是一个基于GUI界面的应用，随处可见用户交互。当用户点击了button按钮，需要执行某个方法来响应button的点击事件，那什么时候才能知道用户点击了按钮呢？你知道吗？反正我是不知道…</p><p>既然不知道用户操作的时间，如何让程序继续运行，可以思考一下。如果我们先把将要执行的方法保存下来，等到用户点击的时候，只需要去让对应的方法执行不就行了吗？</p><a id="more"></a><img style="width: 500px;display: block;margin: 0 auto;" data-src="http://source.mnnuu.cn/websources/blog/2020-03-03/1.png" alt=""><br/><p>代码实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> events = &#123;</span><br><span class="line">    eventOb: &#123;&#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        订阅事件并指定方法</span></span><br><span class="line"><span class="comment">        [params.type] 事件名</span></span><br><span class="line"><span class="comment">        [params.fn] 方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    on (type, fn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.eventOb[type]) <span class="keyword">this</span>.eventOb[type] = [];</span><br><span class="line">        <span class="keyword">this</span>.eventOb[type].push(fn);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        取消订阅某个事件</span></span><br><span class="line"><span class="comment">        [params.type] 事件名</span></span><br><span class="line"><span class="comment">        [params.fn] 需要取消订阅的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    off (type, fn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.eventOb[type]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.eventOb[type].findIndex(<span class="function"><span class="params">item</span> =&gt;</span> fn === item);</span><br><span class="line">        index &gt; <span class="number">-1</span> &amp;&amp; <span class="keyword">this</span>.eventOb[type].splice(index, <span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        触发一个事件</span></span><br><span class="line"><span class="comment">        [params.type] 事件名</span></span><br><span class="line"><span class="comment">        [params.payload] 携带的参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    emit (type, payload) &#123;</span><br><span class="line">        <span class="keyword">const</span> arrFn = <span class="keyword">this</span>.eventOb[type];</span><br><span class="line">        <span class="keyword">if</span> (!arrFn || !arrFn.length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (arrFn.length) &#123;</span><br><span class="line">            <span class="keyword">const</span> fn = arrFn.shift();</span><br><span class="line">            fn.call(<span class="keyword">this</span>, payload);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn1 = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count, <span class="string">'我订阅了点击事件, 我要去更新数据'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count, <span class="string">'我订阅了点击事件, 我要执行一个酷炫的动画'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">events.on(<span class="string">'click'</span>, fn1);</span><br><span class="line">events.on(<span class="string">'click'</span>, fn2);</span><br><span class="line">events.emit(<span class="string">'click'</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 10 "我订阅了点击事件, 我要去更新数据"</span></span><br><span class="line"><span class="comment">// 10 "我订阅了点击事件, 我要执行一个酷炫的动画"</span></span><br></pre></td></tr></table></figure><p>这就是一个典型的观察者模式，先将所有要订阅的事件以及对应的方法( <strong>‘click’</strong> 事件和其对应的方法队列 )保存起来，然后在某个特定的时间点通知事件执行队列中的每一个方法。 </p><p>简单举个例，你在追某一部国产马震神剧。但是呢，这部剧比较傲娇，每周不定时的更新，这就让你急切想看到马震画面的心情变得很烦躁。诶，这个时候某个追剧app提醒你了，想要获取一手更新视频，请订阅哦！你露出一丝丝yx，淡定的点开，页面中有很多种订阅方式，</p><ul><li>该剧更新后，请发邮箱通知我。</li><li>该剧更新后，请直接给我弹个app推送。</li><li>该剧更新后，羞羞的画面，不能让女朋友看见。请发送手机短信通知我。</li></ul><p>这里场景中的 <strong>追剧app</strong> 指代-发布方(手动emit <strong>雷剧更新事件</strong>)，而 <strong>你</strong> 向App订阅的 <strong>雷剧更新事件</strong> 和通知方式相当于 <strong>eventOb</strong> 中的订阅事件和订阅事件对应的方法。当 <strong>追剧app</strong> 接收到视频更新的消息后，会 <strong>emit</strong> 也就是触发 <strong>雷剧更新事件</strong>，然后依次执行该事件对应的方法(每个用户订阅时选择的通知方式)</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
