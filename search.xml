<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Javascript继承</title>
      <link href="/2020/09/04/javascript%E7%BB%A7%E6%89%BF/"/>
      <url>/2020/09/04/javascript%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>javascript常用的继承方案</p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.courses = [<span class="string">'Math'</span>, <span class="string">'Chinese'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi My name is '</span>, name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Child(<span class="string">'张三'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> ls = <span class="keyword">new</span> Child(<span class="string">'李四'</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">zs.courses.push(<span class="string">'English'</span>); <span class="comment">// 个zs实例新增一个course。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(zs); <span class="comment">// Child &#123;__proto__: Parent &#123;courses: ['Math',  'Chinese', 'English']&#125;&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(ls); <span class="comment">// Child &#123;__proto__: Parent &#123;courses: ['Math',  'Chinese', 'English']&#125;&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(zs <span class="keyword">instanceof</span> Child)</span><br></pre></td></tr></table></figure><p>通过原型链来继承父类问题：</p><ul><li>1、不能对Child的name进行初始化赋值；</li><li>2、实例zs，和ls的原型指向同一个Parent实例，共用引用属性，当其中一个实例修改，会修改原型对象上的数据，导致其它实例数据同时被篡改；</li></ul><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi! my name is '</span>, name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Child(<span class="string">'张三'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> ls = <span class="keyword">new</span> Child(<span class="string">'李四'</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Child &#123;</span></span><br><span class="line"><span class="comment">*   age: 20,</span></span><br><span class="line"><span class="comment">*   name: '张三',</span></span><br><span class="line"><span class="comment">*   foo: f ()</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="built_in">console</span>.log(zs);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Child &#123;</span></span><br><span class="line"><span class="comment">    age: 21,</span></span><br><span class="line"><span class="comment">    name: '李四',</span></span><br><span class="line"><span class="comment">    foo: f ()</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="built_in">console</span>.log(ls);</span><br></pre></td></tr></table></figure><p>构造函数继承问题：</p><ul><li>每一次创建Child实例，都会执行一遍Parent方法，解决了引用类型的问题，但是每次都调用父类构造方法，不能复用，造成性能损失。</li><li>只能继承Parent类的实例属性/方法，不能继承Parent父类原型上的属性/方法。</li></ul><h3 id="组合模式继承"><a href="#组合模式继承" class="headerlink" title="组合模式继承"></a>组合模式继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.courses = [<span class="string">'Math'</span>, <span class="string">'Chinese'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.books = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">Parent.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child; <span class="comment">// 将Child原型上的constructor执向自身，保持一致</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Child(<span class="string">'张三'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> ls = <span class="keyword">new</span> Child(<span class="string">'李四'</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(zs);</span><br><span class="line"><span class="built_in">console</span>.log(ls);</span><br></pre></td></tr></table></figure><p>组合继承的问题：</p><ul><li>会调用两次Parent，第一次是在Child构造函数中，通过构造函数的方式继承Parent，第二次是通过原型的方式继承，会使Child实例中有两份Parent中的属性/方法（Child实例中包含一份，Child原型上包含一份）。</li><li>同样每次创建Child实例都会执行一遍Parent构造函数。</li></ul><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ob = &#123;<span class="attr">name</span>: <span class="string">'张三'</span>, <span class="attr">books</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(ob); <span class="comment">// 将对象已有的属性和方法通过新建一个对象，将这些属性和方法放到原型上去。</span></span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* &#123;</span></span><br><span class="line"><span class="comment">*   __proto__: &#123;</span></span><br><span class="line"><span class="comment">*       name: '张三',</span></span><br><span class="line"><span class="comment">*       books: [1, 2, 3]</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p>原型式继承的问题：</p><ul><li>需要一个对象“ob”</li><li>引用问题依然存在。</li></ul><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  Foo.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line">    <span class="keyword">const</span> clone = object(original);  </span><br><span class="line">    <span class="comment">// const clone = Object.create(original);  </span></span><br><span class="line">    <span class="comment">// 以某种方式来增强这个对象</span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寄生式继承问题：</p><ul><li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点和构造函数模式类似。</li></ul><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>在组合模式的基础上增加了寄生模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendsClass</span> (<span class="params">sub, sup</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> temp = <span class="built_in">Object</span>.create(sup.prototype); <span class="comment">// 将父类的原型重新生成一个对象，把这些原型的属性和方法赋值给这个对象的原型</span></span><br><span class="line">    temp.constructor = sub;</span><br><span class="line">    sub.prototype = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Parent,</span><br><span class="line">    sayHi () &#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">extendsClass(Child, Parent);</span><br><span class="line">Child.prototype.sayFather = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi my father'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Parent(<span class="string">'张三他爸'</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p, c);</span><br></pre></td></tr></table></figure><p>寄生组合式继承优点：</p><ul><li>相比组合继承模式，寄生组合式继承只执行了一次父类构造函数，构造函数生成的属性不会再添加子类的原型（原型没有xx.prototype = new Parent()）</li><li>子类原型和继承自父类的原型很好区分，子类的prototype属于自己的属性/方法，子类的prototype.prototype属于父类Parent的属性/方法。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 之 Generator函数</title>
      <link href="/2020/09/02/2020-09-02/"/>
      <url>/2020/09/02/2020-09-02/</url>
      
        <content type="html"><![CDATA[<p>Generator函数是ES6提供的一种异步编程解决方案。</p><a id="more"></a><h2 id="执行栈与事件队列"><a href="#执行栈与事件队列" class="headerlink" title="执行栈与事件队列"></a>执行栈与事件队列</h2><p>JavaScript是单线程非阻塞的脚本语言，意味着JS代码在执行的时候都是通过一个线程（主线程）来执行。如果都是同步代码，js引擎从上到下依次执行，当遇到比较耗时的操作（I/O、AJAX请求等）时，需要一直等待其执行完毕才能继续向下执行。这就会造成阻塞，UI界面将会一直卡着不动，不能进行更多的操作，这将是一种很糟糕的体验。为了解决阻塞的问题，JS引擎引入了<strong>异步队列</strong>的概念。</p><p>JS引擎执行代码的时候，会通过一个<strong>执行栈</strong>来管理各个<strong>执行上下文</strong>。在一个脚本执行的时候，如果是函数，则会创建该函数的执行上下文环境（<strong>在创建阶段会生成活动对象VO、创建作用域链、确定this指向。执行阶段，VO 激活变为 AO （VO + function params + arguments），这时候就可以访问其作用域链</strong>），然后将这个<strong>执行上下文</strong>压入执行栈中，并进入这个<strong>执行上下文环境</strong>执行其中的代码，执行过程中如果再次遇到函数则会重复刚刚的操作。当这个执行环境中的代码执行完毕并返回结果后，js会退出这个执行上下文环境并将其销毁，回到上一个执行上下文环境中。这个过程将会反复进行，直到执行栈中的代码全部执行。</p><p>以上的过程说的都是同步代码，那么当一个异步代码执行后会发生啥？再一次申明js是非阻塞的，实现这一点的关键在于 <strong>事件队列</strong></p><p>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务，当一个异步事件返回结果之后，js引擎会将这个事件push到一个事件队列中，事件队列中的任务并不会立即执行，而是会等到执行栈中的任务执行完毕（处于闲置状态时），主线程会去查找事件队列是否有任务，如果有，那么主线程会从中取出第一个事件，加入到执行栈中执行，如此反复就形成了一个无限循环，这也是浏览器的<strong>事件循环机制</strong></p><p><img data-src="https://media.prod.mdn.mozit.cloud/attachments/2020/02/23/17124/7cbd04169bbb5be13ede088ff0833882/The_Javascript_Runtime_Environment_Example.svg" alt=""></p><hr><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>所谓的异步编程，通俗来讲就是先执行一段代码，这段代码我不知道什么时候能够执行完，那么我给它一个方法，这个方法会在它执行完后被调用。</p><p><strong>常用的异步编程方式</strong></p><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li><li>Promise对象</li></ul><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>JavasScript语言对异步编程的实现，就是通过回调函数来实现的，所谓的回调函数就是把任务第二段单独写在一个函数内，等到重新执行这个任务的时候，调用这个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line">fs.readFile(path, <span class="string">'utf-8'</span>, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过传入一个callback函数，去接收readFile执行完毕过后的参数，然后执行。</span></span><br></pre></td></tr></table></figure><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">e</span>) </span>&#123;<span class="built_in">console</span>.log(e)&#125;</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也是通过回调函数在触发过后来执行相应的逻辑</span></span><br></pre></td></tr></table></figure><h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!q.includes(callback)) q.push(callback)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emitEvent</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = q.shift();</span><br><span class="line">    fn.call(<span class="literal">null</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addEvent(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'触发了什么事件'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某个地方触发了事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">emitEvent(&#123;&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>回调函数本身并没有什么问题，它的问题出现在多个回调嵌套。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(file_a, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  fs.readFile(file_b, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以想象一下，当出现多重嵌套的时候。代码和逻辑会乱做一团，因为多个异步操作嵌套形成了强耦合，这种情况被称为<strong>“回调地狱”</strong></p><p>Promise就是解决这个问题而被提出来的，它不是新的语法，而是回调函数的另一种实现方式，可以将多重嵌套用链式调用的方式来运行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设readFile已被Promise化</span></span><br><span class="line">readFile(file_a)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> readFile(file_b))</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> readFile(file_c))</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'读取完毕'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，使用Promise化的readFile执行过程更加清楚。那么除了Promise有没有更好的方式来实现异步编程呢？</p><p>有的。</p><h2 id="Generator生成器"><a href="#Generator生成器" class="headerlink" title="Generator生成器"></a>Generator生成器</h2><p>一个简单的生成器的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>  <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span>  <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line">g.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: 2, dong: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>generator在调用的时候并不会立即执行，而是返回一个指向内部状态的指针对象（遍历器对象），必须调用遍历器对象的next方法，使指针移向下一个状态，直到遇到yield表达式或者return为止。<strong>yield表达式可以理解为一个暂停标志，只有在调用遍历器对象的next方法才能恢复执行</strong>。</p><p>next方法返回一个对象，包含两个属性。一个是<strong>value</strong>属性，对应当前yield表达式对应的值，另一个是<strong>done</strong>属性，表示当前遍历是否结束。</p><p>generator函数还可通过next方法传值到生成器内部。<strong>yield</strong>表达式自身并没有返回值，也可以说是总是<strong>返回的undefined</strong>，next方法可以传入一个参数，<strong>这个参数就会被当做上一个yield表达式的返回值</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> a1 = <span class="keyword">yield</span> <span class="string">'A'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(a1, <span class="string">'a1'</span>);</span><br><span class="line">    <span class="keyword">let</span> a2 = <span class="keyword">yield</span> <span class="string">'B'</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">console</span>.log(a2, <span class="string">'a2'</span>);</span><br><span class="line">    <span class="keyword">let</span> a3 = <span class="keyword">yield</span> <span class="string">'C'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(a3, <span class="string">'a3'</span>);</span><br><span class="line">    <span class="keyword">let</span> a4 = <span class="keyword">yield</span> <span class="string">'D'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(a4, <span class="string">'a4'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next(<span class="number">1</span>);           <span class="comment">// &#123;value: A, done: false&#125;</span></span><br><span class="line">            <span class="comment">// 执行到 yield 'A' 的时候暂停执行，</span></span><br><span class="line">            <span class="comment">// 此时传入的 “1”，由于是上一个yield表达式的返回值，</span></span><br><span class="line">            <span class="comment">// 所以在第一次使用next方法时，传递参数是无效的。</span></span><br><span class="line">            <span class="comment">// V8引擎会直接忽略第一次next方法的参数。</span></span><br><span class="line">                </span><br><span class="line">g.next(<span class="number">2</span>); <span class="comment">// 2 a1      &#123;value: B, done: false&#125;</span></span><br><span class="line">g.next(<span class="number">3</span>); <span class="comment">// 3 a2      &#123;value: C, done: false&#125;</span></span><br><span class="line">g.next(<span class="number">4</span>); <span class="comment">// 4 a3      &#123;value: D, done: false&#125;</span></span><br><span class="line">g.next(<span class="number">5</span>); <span class="comment">// 5 a4      &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>如果想要第一次调用next方法就能够传入值，可以在generator函数外包一层</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapper</span> (<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> g = gen(...args);</span><br><span class="line">      <span class="keyword">let</span> r = g.next();</span><br><span class="line">      <span class="built_in">console</span>.log(r, <span class="string">'第一次执行next的返回值'</span>);</span><br><span class="line">      <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w = wrapper(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> r = <span class="keyword">yield</span> <span class="number">123</span>; <span class="comment">// 在包装函数返回的函数内部执行第一个 next 方法。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'firstInput:'</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'DONE'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">w().next(<span class="string">'test'</span>); <span class="comment">// 123, 第一次执行next的返回值</span></span><br><span class="line">                  <span class="comment">// firstInout: test</span></span><br></pre></td></tr></table></figure><p>利用生成器generator这一特性（遇到yield表达式会暂停执行，next方法可以传入参数作为上一个yield表达式的返回值），结合回调函数来看看下面的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(path, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> readFile(<span class="string">'./package.json'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> result2 = <span class="keyword">yield</span> readFile(<span class="string">'./README.md'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行该函数并注册一个回调方法。</span></span><br><span class="line">g.next().value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  g.next().value的值是readFile执行后返回的一个函数</span></span><br><span class="line"><span class="comment">  function(callback) &#123;</span></span><br><span class="line"><span class="comment">     fs.readFile(path, 'utf-8', callback);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>执行r.value方法会去读取文件，并将传入的callback作为fs.readFile的回调函数</strong>。等到文件读取完毕之后，才会执行这个回调函数。思考一下，那么我们要如何在generator函数中同步获取到文件的内容呢？</p><p>我们知道了next方法传入的参数可以作为上一个yield表达式的返回值，那么我们只要通过下一个next方法把结果传入进去不就行了吗！！！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// result 就能就收到data啦</span></span><br><span class="line">    g.next(data).value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        g.next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个时候就能在gen函数中愉快的拿到文件内容，并同步执行了。</p><p>写到这，可以思考一下，如果generator函数中有多个异步方法要同步执行，还得自己去调用next().value(…)来执行，这种嵌套比回调地狱还恶心。而且上面的逻辑都是相同的，我们何不写一个方法来自动递归执行呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">let</span> gen = fn();</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">let</span> result = gen.next(data);</span><br><span class="line">         <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">         result.value(next);</span><br><span class="line">     &#125;</span><br><span class="line">     next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> r1 = <span class="keyword">yield</span> readFile(<span class="string">'./package.json'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r1.length);</span><br><span class="line">  <span class="keyword">let</span> r2 = <span class="keyword">yield</span> readFile(<span class="string">'./package.json'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r2.length)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果yield表达式右边是一个Promise呢？实现一个基于Promise的自动执行的generator生成器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span> (<span class="params">interval</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(interval);</span><br><span class="line">        &#125;, interval);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> gen = fn();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = gen.next(data);</span><br><span class="line">    <span class="keyword">if</span>(res.done) <span class="keyword">return</span> res.value;</span><br><span class="line">    res.value.then(<span class="function">(<span class="params">data</span>) =&gt;</span> next(data));</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> i1 = <span class="keyword">yield</span> delay(<span class="number">1000</span>); <span class="comment">// 时隔1s，将interval赋值给i1</span></span><br><span class="line">  <span class="built_in">console</span>.log(i1);</span><br><span class="line">  <span class="keyword">const</span> i2 = <span class="keyword">yield</span> delay(<span class="number">2000</span>); <span class="comment">// 再次时隔2s， 将interval赋值给I2</span></span><br><span class="line">  <span class="built_in">console</span>.log(i2);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这也是ES7中async/await的核心原理，async/await就是一个自动执行的生成器的语法糖，async可以理解为 function 后面的 “*”，await可以理解成yield表达式。<br>async/await在语义更加清晰。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COCOS CREATOR 学习合集</title>
      <link href="/2020/08/18/2020-08-18/"/>
      <url>/2020/08/18/2020-08-18/</url>
      
        <content type="html"><![CDATA[<p>1、锚点、坐标转换（世界坐标，节点的坐标等）<br>2、万物皆可传入properties<br>3、节点和组件以及他们的获取方式（getChildByName、getComponent）<br>4、常驻节点保存数据（场景切换的时候，数据不销毁），也可通过模块的形式来做（闭包）。<br>5、Sprite的填充模式，FillCenter、FillRange来做旋转渲染的动效<br>6、内置节点的node可以通过 this.xxx.node 来访问。</p><p>7、animation可以用来做页面的动画，<br>8、cc.tween缓动动画<br>9、屏幕适配，设置标准的宽高，然后通过widget来布局</p><a id="more"></a><p>properties可以设置get、set属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> XXX <span class="keyword">extends</span> cc.Component &#123;</span><br><span class="line">    <span class="meta">@property</span></span><br><span class="line">    <span class="keyword">private</span> _value: <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@property</span></span><br><span class="line">    <span class="keyword">get</span> value(): <span class="built_in">number</span> | <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> value(v: <span class="built_in">number</span> | <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找节点<br>1、this.node.getChildByName(name)<br>2、通过properties传入</p><p>查找组件<br>this.getComponent(cc.Label)<br>this.getComponent(componentName)</p><p>全局名字查找<br>cc.find(name, startNode);</p><p>创建节点<br>new cc.Node(type)</p><p>new cc.Node(‘Sprite’);<br>new cc.Node(cc.Sprite);<br>new cc.Sprite();</p><p>克隆已有节点 或 创建预制节点<br>cc.instantiate(node);</p><p>销毁节点<br>node.destroy();</p><p>加载场景<br>cc.director.loadScene(name);</p><p>v2.4新增一种加载方式<br>bundle.loadScene(name, function(err, scene) {<br>    cc.director.runScene(scene); // 手动运行场景<br>})</p><p>常驻节点（管理场景资源，传递参数，管理状态等）<br>因为引擎同时只会运行一个场景，当切换场景的时候，默认会将场景内所有的节点个其他实例销毁。<br>通过使用常驻节点来进行场景之间的数据传递。</p><p>cc.game.addPersistRootNode(node);<br>cc.game.removePersistRootNode(node); // 取消常驻<br>在挂载到节点的脚本文件中通过 cc.find(node) 来访问常驻节点</p><p>预加载场景<br>cc.director.preloadScene(name, function () {});<br>然后在某个地方通过<br>cc.director.loadScene(name)来加载预加载完毕的场景；</p><p>获取和加载资源<br>在Creator中，所有继承自cc.Asset的类型都统称为资源，如cc.Texture2D、cc.SpriteFrame、cc.AnimationClip、cc.Prefab等等</p><blockquote><p>当引擎在加载场景的时候，会先自动加载场景关联到的资源，这些资源如果再关联其他资源，其他也会被先加载，等加载完成后，场景加载才会结束</p></blockquote><p>动态加载 “resources”</p><p>路径：/assets/resource/assets/anim.clip</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cc.resources.load(<span class="string">"assets/anim"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, clip</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注：所有需要通过脚本动态加载的资源，都必须放置在 resources 文件夹或它的子文件夹下。resources 文件夹需要在 assets 根目录 下手动创建</strong></p><p>路径：/assets/resources/assets/a.png</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc.resources.load(<span class="string">"assets/a"</span>, cc.SpriteFrame, <span class="function"><span class="keyword">function</span> (<span class="params">err, frame</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接加载 "assets/a" 得到的类型将会是cc.Texture2D, 需要制定第二个参数为资源的类型，才能加载得到图片生成的cc.SpriteFrame;</span></span><br></pre></td></tr></table></figure><p>加载图集中的SpriteFrame的时候，需要先加载图集，然后通过图集来获取SpriteFrame</p><p>事件监听和触发</p><p>this.node.on(eventName, eventHandler, this);<br>this.node.emit(eventName, eventHandler, this);<br>this.node.dispatchEvent(new cc.Event.EventCustom(eventName, type), eventHandler, this);</p><p>this.node.off(eventName, eventHandler, this);</p><p>节点系统事件<br>node.on(cc.Node.EventType.MOUSE_DOWN, eventHandler, this);</p><p>鼠标事件类型<br>cc.Node.EventType.MOUSE_DOWN -&gt; mousedown<br>cc.Node.EventType.MOUSE_ENTER -&gt; mouseenter<br>cc.Node.EventType.MOUSE_MOVE -&gt; mousedown<br>cc.Node.EventType.MOUSE_LEAVE -&gt; mouseleave<br>cc.Node.EventType.MOUSE_UP -&gt; mouseup<br>cc.Node.EventType.MOUSE_WHEEL -&gt; mousewheel</p><p>鼠标事件的重要API<br>getScrollY() // 获取滚轮滚动的Y轴距离<br>getLocation() // 获取鼠标位置对象，包含X和Y属性<br>getLocationX() // 获取鼠标X轴的位置<br>getLocationY() // 获取鼠标Y轴的位置<br>getPreviousLocation() // 获取鼠标事件上一次触发的位置对象 {x,y}<br>getDelta() // 获取鼠标距离上一次事件移动的距离对象，{x,y}<br>getButton()</p><p>触摸事件类型和事件对象<br>cc.Node.EventType.TOUCH_START -&gt; touchstart<br>cc.Node.EventType.TOUCH_MOVE  -&gt; touchmove<br>cc.Node.EventType.TOUCH_END   -&gt; touchend<br>cc.Node.EventType.TOUCH_CANCEL -&gt; touchcancel</p><p>API<br>touch() // 获取触点对象<br>getID() // 获取触点ID，用于多点触摸的逻辑判断<br>getLocation() // 获取触点位置对象 {x,y}<br>getLocationX() // 获取触点X轴位置<br>getLocationY() // 获取触点Y轴位置<br>getPreviousLocation() // 获取触点上一次触发事件时的位置对象，对象包含 x 和 y 属性<br>getStartLocation() // 获取触点初始时的位置对象，对象包含 x 和 y 属性<br>getDelta() // 获取触点距离上一次事件移动的距离对象，对象包含 x 和 y 属性</p><p>触摸事件冒泡可以通过 e.stopPropagation() 阻止</p><p>将触摸或者鼠标事件注册在捕获阶段<br>thia.node.on(cc.Event.EventType.TOUCH_START, handler, this, true); // 多传入一个true</p><p>多点触摸<br>关闭多点触摸（防误触）<br>cc.macro.ENABLE_MULTI_TOUCH = false;</p><p>暂停节点系统事件<br>this.node.pauseSystemEvents();</p><p>恢复节点系统事件<br>this.node.resumeSystemEvents();</p><h2 id="全局系统事件"><a href="#全局系统事件" class="headerlink" title="全局系统事件"></a>全局系统事件</h2><p>全局系统事件指与节点树不相干的各种全局事件，由cc.systemEvent来统一派发。</p><ul><li>键盘事件</li><li>设备重力感应事件</li></ul><p>cc.systemEvent.on(type, handler, this);</p><p>cc.SystemEvent.EventType.KEY_UP; // 键盘弹起<br>cc.SystemEvent.EventType.KEY_DOWN; // 键盘按下<br>cc.SystemEvent.EventType.DEVICEMOTION; // 重力感应事件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript深入 之 call、apply、bind方法</title>
      <link href="/2020/08/10/2020-08-10/"/>
      <url>/2020/08/10/2020-08-10/</url>
      
        <content type="html"><![CDATA[<p>手动实现function的call、apply和bind方法。</p><a id="more"></a><h2 id="函数原型方法call-、apply-实现"><a href="#函数原型方法call-、apply-实现" class="headerlink" title="函数原型方法call()、apply()实现"></a>函数原型方法call()、apply()实现</h2><p>call和apply都会改变this指向，并且指定参数调用某个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*声明一个对象和一个方法*/</span></span><br><span class="line"><span class="keyword">var</span> ob = &#123;<span class="attr">str</span>: <span class="string">'nandou'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.str;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* call函数实现 */</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> args = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span>+ args +<span class="string">')'</span>);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line">foo.call2(ob, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// nandou</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* apply函数实现 */</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span>+ args +<span class="string">')'</span>);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line">foo.apply2(ob, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// nandou</span></span><br></pre></td></tr></table></figure><h2 id="函数原型方法bind-实现"><a href="#函数原型方法bind-实现" class="headerlink" title="函数原型方法bind()实现"></a>函数原型方法bind()实现</h2><p>bind函数，可以绑定this，并返回一个新的函数，同时还能作为构造函数去实例化一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> ob = &#123;</span><br><span class="line">    str: <span class="string">'nandou'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.friend = <span class="string">'aa'</span>;</span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...a</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.apply(context, [...args, ...a]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> BindFn = Foo.bind2(ob, <span class="number">123</span>);</span><br><span class="line">BindFn(); <span class="comment">// nandou</span></span><br></pre></td></tr></table></figure><p>结果看似没有问题了，this也绑定到了ob上，打印出了str的值“nandou”，返回的this也是指向的ob对象。</p><p><strong>但是在ECMAScript规范中</strong></p><blockquote><p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p></blockquote><p>举个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ob = &#123;<span class="attr">str</span>: <span class="string">'nandou'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = <span class="string">'man'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.str);</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> BindFn = Foo.bind(ob);</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> BindFn(); <span class="comment">// this.str -&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(vm);</span><br><span class="line"><span class="built_in">console</span>.log(vm.sex); <span class="comment">// man</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.age); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>注意：Foo函数的this.str返回的是undefined，说明此时的this绑定已经失效了。vm.sex、vm.age都有值，说明new BindFn()之后，this已经指向了vm。</p><p>我们来试试看上面的代码可行吗。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...a</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.apply(context, [...args, ...a]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> ob = &#123;<span class="attr">str</span>: <span class="string">'nandou'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = <span class="string">'man'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.str);</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> BindFn = Foo.bind2(ob);</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> BindFn(); <span class="comment">// this.str -&gt; nandou</span></span><br><span class="line"><span class="built_in">console</span>.log(vm); <span class="comment">// f &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.sex); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>并没有哈！！优化一下</p><p>稍加改进之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">let</span> Bound = <span class="function"><span class="keyword">function</span> (<span class="params">...a</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.apply(context, [...args, ...a]);</span><br><span class="line">    &#125;;</span><br><span class="line">    Bound.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    <span class="keyword">return</span> Bound;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ob = &#123;<span class="attr">str</span>: <span class="string">'nandou'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = <span class="string">'man'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.str);</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> BindFn = Foo.bind2(ob);</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> BindFn(); <span class="comment">// this.str -&gt; nandou</span></span><br><span class="line"><span class="built_in">console</span>.log(BindFn.prototype === Foo.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(vm); <span class="comment">// Bound &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.sex); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.age); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>我们将Foo函数的原型赋值给了Bound函数，然后将Bound函数返回，这时通过new关键字创建的<strong>实例vm原型（<strong>proto</strong>）</strong>指向的就是<strong>Foo函数的原型（prototype）</strong></p><p>此时还有两个小问题：<br>1、 当修改BindFn函数prototype的时候，Foo的prototype也会跟着改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BindFn.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype); <span class="comment">// &#123;friend: "aa", sayHi: f, constructor: f&#125;</span></span><br></pre></td></tr></table></figure><p>此时，Foo的原型也被污染。做一点小小的改进。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">let</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> Bound = <span class="function"><span class="keyword">function</span> (<span class="params">...a</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.apply(context, [...args, ...a]);</span><br><span class="line">    &#125;;</span><br><span class="line">    F.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    Bound.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    <span class="keyword">return</span> Bound;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ob = &#123;<span class="attr">str</span>: <span class="string">'nandou'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = <span class="string">'man'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.str);</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> BindFn = Foo.bind2(ob);</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> BindFn(); <span class="comment">// this.str -&gt; nandou</span></span><br><span class="line"><span class="built_in">console</span>.log(BindFn.prototype === Foo.prototype); <span class="comment">// false 此时BindFn.prototype已经是F函数通过new关键字创建的实例了</span></span><br><span class="line"><span class="built_in">console</span>.log(vm); <span class="comment">// Bound &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.sex); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.age); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>但是此时的Foo函数依旧绑定的ob对象，this依旧有问题，再做一点改进。</p><p><strong>最终版本：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">let</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> Bound = <span class="function"><span class="keyword">function</span> (<span class="params">...a</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// instanceof 运算符用于检测 某个实例对象的原型链上是否有 构造函数的原型</span></span><br><span class="line">        <span class="comment">// object instanceof constructor 判断this对应的原型链上是否有F的原型</span></span><br><span class="line">        <span class="comment">// 如果是通过构造函数的方式来调用的，则判断一下this指向，</span></span><br><span class="line">        <span class="comment">// 因为Bound函数的原型是F函数new之后的实例，所以vm的this中包含了F函数的原型</span></span><br><span class="line">      <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> F ? <span class="keyword">this</span> : context, [...args, ...a]);</span><br><span class="line">    &#125;;</span><br><span class="line">    F.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    Bound.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    <span class="keyword">return</span> Bound;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ob = &#123;<span class="attr">str</span>: <span class="string">'nandou'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = <span class="string">'man'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.str);</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> BindFn = Foo.bind2(ob);</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> BindFn(); <span class="comment">// this.str -&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(BindFn.prototype === Foo.prototype); <span class="comment">// false 此时BindFn.prototype已经是F函数通过new关键字创建的实例了</span></span><br><span class="line"><span class="built_in">console</span>.log(vm); <span class="comment">// Bound &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.sex); <span class="comment">// man</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.age); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript深入 之 原型（prototype）</title>
      <link href="/2020/07/20/2020-07-20-1/"/>
      <url>/2020/07/20/2020-07-20-1/</url>
      
        <content type="html"><![CDATA[<p>每个函数都有一个prototype属性，该属性指向一个对象，这个对象就是通过实例化这个函数创建的实例的原型…</p><a id="more"></a><h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'TT'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个函数都有一个prototype属性，</span></span><br><span class="line"><span class="comment">// 该属性指向了一个对象，这个对象是（通过调用该构造函数而创建的实例的 —— p）原型，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个实例都会从原型“继承”属性，</span></span><br><span class="line"><span class="comment">// 每个实例化的对象都会有一个“__proto__”的属性，</span></span><br><span class="line"><span class="comment">// 该属性指向该实例的原型 也就是 Person的prototype。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们知道，对象都有自己的原型，既然Person.prototype是一个对象，那么它的原型是什么呢？</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 Object的原型指向是null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><img data-src="https://source.mnnuu.cn/websources/blog/2020-07-20/prototype.png" alt="文件结构"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript深入 之 JS的执行过程</title>
      <link href="/2020/07/20/2020-07-20-2/"/>
      <url>/2020/07/20/2020-07-20-2/</url>
      
        <content type="html"><![CDATA[<p>深入了解JavaScript的执行过程，原型链，作用域，执行上下文，this指向，闭包…</p><a id="more"></a><blockquote><p>作用域是指程序源代码中定义变量的区域。作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p></blockquote><p>JavaScript 是词法作用域，在编译阶段(JS执行过程分为编译阶段、执行阶段)的时候作用域就确定了。</p><h2 id="一、JavaScript的执行过程"><a href="#一、JavaScript的执行过程" class="headerlink" title="一、JavaScript的执行过程"></a>一、JavaScript的执行过程</h2><h3 id="1、编译阶段"><a href="#1、编译阶段" class="headerlink" title="1、编译阶段"></a>1、编译阶段</h3><p>当执行JavaScript之前编译器会先对js代码进行词法分析、然后生成可执行代码，并确定作用域。</p><h3 id="2、执行阶段"><a href="#2、执行阶段" class="headerlink" title="2、执行阶段"></a>2、执行阶段</h3><p><strong>执行上下文 和 执行上下文栈</strong><br>当JS引擎执行每一段可执行代码的时候，会创建对应的<strong>执行上下文</strong>。而<strong>执行上下文栈</strong>是JS引擎创建来管理执行上下文的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECSTACK = [ globalContext ]</span><br></pre></td></tr></table></figure><p>JavaScript引擎执行js代码的时候，最先遇到的是全局代码，所以初始化 <strong>“执行上下文栈”</strong> 的时候会先向其压入一个 <strong>“全局执行上下文”</strong>，并且只有当应用程序结束的时候才会清空。所以栈底永远有一个 <strong>“全局执行上下文”</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 看代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'fun3'</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123; fun3() &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123; fun2() &#125;</span><br><span class="line">fun1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码展示执行过程</span></span><br><span class="line">ECSTACK.push(<span class="xml"><span class="tag">&lt;<span class="name">fun1</span>&gt;</span> functionContext);</span></span><br><span class="line"><span class="xml">// func1 中执行了 fun2 创建fun2的执行上下文并压入执行栈中</span></span><br><span class="line">ECSTACK.push(&lt;fun2&gt; functionContext);</span><br><span class="line">// 执行fun2代码，执行了 fun3 创建fun3的执行上下文并压入执行栈</span><br><span class="line">ECSTACK.push(&lt;fun3&gt; functionContext);</span><br><span class="line"></span><br><span class="line">// fun3 执行完毕</span><br><span class="line">ECSTACK.pop();</span><br><span class="line">// fun2 执行完毕</span><br><span class="line">ECSTACK.pop();</span><br><span class="line">// fun1 执行完毕</span><br><span class="line">ECSTACK.pop();</span><br></pre></td></tr></table></figure><p><strong>对于每个执行上下文，都可分为两个阶段</strong></p><p><strong>创建阶段</strong></p><ul><li>创建变量对象（Variable object, VO）</li><li>创建作用域链（Scope chain）</li><li>确定this的指向<br><strong>执行阶段</strong></li><li>变量对象激活，变为活动对象(合成作用域链)。 AO = VO + function parameters + arguments</li></ul><p>总结：</p><ul><li>全局上下文的变量对象是全局对象</li><li>函数上下文的变量对象初始化只包括Arguments对象</li><li>进入执行上下文时会给变量对象 添加形参、函数声明、变量声明等初始的属性值</li><li>在代码执行阶段、会再次修改变量对象的属性值</li></ul><h4 id="创建变量对象-Variable-object"><a href="#创建变量对象-Variable-object" class="headerlink" title="创建变量对象 (Variable object)"></a>创建变量对象 (Variable object)</h4><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。其中全局上下文的变量对象就是全局对象（window），对于全局上下文，全局对象是浏览器预置的对象（可以通过该对象调用浏览器的原生API），该对象拥有像路由、存储等等内置的一些方法。</p><p>变量对象会在所属的执行上下文创建阶段生成，其包含了其执行环境的变量（var声明的变量）、函数声明，形参等等（这个阶段只是创建VO对象，不能访问）</p><h4 id="创建作用域链（scope-chain）"><a href="#创建作用域链（scope-chain）" class="headerlink" title="创建作用域链（scope chain）"></a>创建作用域链（scope chain）</h4><p>函数在声明的时候，会将当前所在的环境中的作用域赋值给内置属性[[SCOPE]]，但此时的作用域并不是当前函数的完整作用域链（不包含自身的作用域），在该函数执行上下文环境创建阶段，将生成的变量对象加入到[[SCOPE]]属性的首位，才构建出了完整的作用域链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">boo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">o</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    boo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在boo函数声明的时候，boo当前的作用域是foo函数能够访问到的全部作用域链</span></span><br><span class="line"><span class="comment">// [foo, globalContext] 此时boo自身的作用域还没有生成</span></span><br><span class="line"><span class="comment">// 当执行boo()的时候，会先创建执行上下文，首先 生成变量对象&#123;a: undefined o: function () &#123;&#125;&#125;</span></span><br><span class="line"><span class="comment">// 然后将变量对象 -&gt; [boo, foo, globalContext] 这就是boo的完整作用域链，在执行阶段激活变量对象，届时就可以访问作用域链了。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算符操作技巧</title>
      <link href="/2020/07/20/2020-07-20/"/>
      <url>/2020/07/20/2020-07-20/</url>
      
        <content type="html"><![CDATA[<h3 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h3><p>1、取奇、偶</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按位与</span></span><br><span class="line"><span class="keyword">let</span> odd = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>), (item, index) =&gt; index)</span><br><span class="line">    .filter(<span class="function"><span class="params">number</span> =&gt;</span> number &amp; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(odd);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序坑合集</title>
      <link href="/2020/07/03/2020-07-03/"/>
      <url>/2020/07/03/2020-07-03/</url>
      
        <content type="html"><![CDATA[<p>小程序开发框架Taro和小程序开发时候遇到的坑</p><a id="more"></a><p>Taro编译bug：css多行省略的属性 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden<span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">-o-text-overflow</span>: ellipsis<span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis<span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box<span class="meta">!important</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 该行属性没有编译到打包文件中，与预期不符 */</span></span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical<span class="meta">!important</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">没有编译到打包文件中，导致省略出错。</span><br><span class="line">解决：</span><br><span class="line"></span><br><span class="line">```<span class="selector-tag">css</span></span><br><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden<span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">-o-text-overflow</span>: ellipsis<span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis<span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box<span class="meta">!important</span>;</span><br><span class="line">  <span class="comment">/*! autoprefixer: ignore next */</span></span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在开发小程序的时候，经常会需要获取载体平台（微信、抖音、头条等）用户的信息，通过用户在载体平台的唯一凭证（openid等）来做用户登录。今天来聊一聊具体应该怎么做。</p></blockquote><h3 id="小程序流程"><a href="#小程序流程" class="headerlink" title="小程序流程"></a>小程序流程</h3><p>首先通过xx.login()方法获取当前用户的code，服务端拿到我们传过去的code去请求平台服务器，获取到用户的openid，然后在自己的数据库通过该openid创建一个用户，此时用户就已经创建完毕。</p><p>服务器端对该用户做登录操作，并把该用户的基本信息（默认的初始信息）+ token传给前端，前端拿到token。如果要获取该用户的详细信息，调用xx.getUserInfo()方法，这时就需要用户授权（弹出一个面板，提示用户授权，授权完毕才能返回详细信息）<br>后更新到自己数据库中。</p><h3 id="抖音-web-页面-OAuth2-0-授权流程"><a href="#抖音-web-页面-OAuth2-0-授权流程" class="headerlink" title="抖音 web 页面 OAuth2.0 授权流程"></a>抖音 web 页面 OAuth2.0 授权流程</h3><p>1、在应用中发起抖音授权登录请求，抖音用户允许授权第三方应用后（扫码确认或账号密码授权登录），确认通过后，会重定向到第三方网站（回调地址），并附带上code字段。</p><p>2、第三方通过code参数，以及ClientKey、ClientSecret等参数，通过API换取access_token。</p><p>3、通过access_token进行接口调用，获取用户基本信息及其他操作。</p><h4 id="静默授权-（用户无感知）"><a href="#静默授权-（用户无感知）" class="headerlink" title="静默授权 （用户无感知）"></a>静默授权 （用户无感知）</h4><p>通过code获取用户openid来做静默登录。scope=login_id</p><p>####</p><p>用户登录过程</p><h4 id="获取小程序指定页面的二维码"><a href="#获取小程序指定页面的二维码" class="headerlink" title="获取小程序指定页面的二维码"></a>获取小程序指定页面的二维码</h4><p>需要后端通过小程序平台的接口去获取buffer 然后保存到本地将地址给到前端。</p><h4 id="bad-code"><a href="#bad-code" class="headerlink" title="bad code"></a>bad code</h4><p>查看客户端、服务端的appId或者appSecret是否正确</p><h4 id="抖音小程序-上传图片的坑"><a href="#抖音小程序-上传图片的坑" class="headerlink" title="抖音小程序 上传图片的坑"></a>抖音小程序 上传图片的坑</h4><p>今天做了一个抖音小程序上传图片的需求，呕… 呕….</p><p>失态了….</p><p>首先通过tt.chooseImage()方法，获取到图片的本地地址，然后通过tt.uploadFile()上传到我方服务器。</p><p>流程很简单，当我做完测试的时候才发现是我太年轻。</p><p>在手机上测试半天。还以为是白名单没配置，转过来去字节跳动小程序平台又配了一个白名单。</p><p>还不行！！</p><p>还能怎么办，只能一步一步debugger、console出来看看。</p><p>对了，说了这么久，到底是什么问题呢？</p><p>Android端上传没问题，后端该返回的都返回了</p><p>iOS端就比较不一样了，chooseImage的时候返回的templatePath会携带有query，正是这个query导致上传出问题。</p><p><img data-src="https://source.mnnuu.cn/websources/blog/2020-07-03/ios.jpg" alt="ios端"><br>这是ios端通过chooseImage选择的图片的路径</p><p><img data-src="https://source.mnnuu.cn/websources/blog/2020-07-03/android.jpg" alt="android端"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tt.chooseImage(&#123;</span><br><span class="line">  success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> path = res.tempFilePaths[<span class="number">0</span>];</span><br><span class="line">   path = path.split(<span class="string">'?'</span>)[<span class="number">0</span>];</span><br><span class="line">   tt.uploadFile(&#123;</span><br><span class="line">     url: <span class="string">'&#123;&#123;https://xxxx.xxx.xx&#125;&#125;'</span>, <span class="comment">// 目标地址</span></span><br><span class="line">     filePath: path, <span class="comment">// 本地文件路径</span></span><br><span class="line">     name: <span class="string">"&#123;&#123;name&#125;&#125;"</span>, <span class="comment">// 名称</span></span><br><span class="line">     success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(res.data));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>OK 搞定！</p><h4 id="Taro-hook-useEffect最后一次的返回要想执行-得注销页面。"><a href="#Taro-hook-useEffect最后一次的返回要想执行-得注销页面。" class="headerlink" title="Taro hook useEffect最后一次的返回要想执行 得注销页面。"></a>Taro hook useEffect最后一次的返回要想执行 得注销页面。</h4><p>如果自己跳转到自己通过push 页面不会销毁，就不会走。</p><h4 id="小程序开发-域名白名单的坑"><a href="#小程序开发-域名白名单的坑" class="headerlink" title="小程序开发 域名白名单的坑"></a>小程序开发 域名白名单的坑</h4><p>uploadFile需要单独添加</p><h4 id="字节跳动小程序-onHide"><a href="#字节跳动小程序-onHide" class="headerlink" title="字节跳动小程序 onHide"></a>字节跳动小程序 onHide</h4><p>Android 打开激励视频不走onHide，IOS 打开激励视频走了onHide</p><h4 id="抖音分享坑出翔"><a href="#抖音分享坑出翔" class="headerlink" title="抖音分享坑出翔"></a>抖音分享坑出翔</h4><p>怎么说呢，最近沉（入）迷（坑）字节跳动小程序，无法自拔。</p><p>字节跳动小程序，主要包括两个平台（头条、抖音）。目前做字节跳动小程序也是主要针对这两个平台来开发。</p><p>字节跳动的分享接收一个templateId的字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> onShareApp = <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;path, title, desc&#125; = params;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">shareOption</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 视频相关</span></span><br><span class="line">        <span class="keyword">let</span> options = &#123;</span><br><span class="line">            path,</span><br><span class="line">            title,</span><br><span class="line">            success: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 成功回调</span></span><br><span class="line">            &#125;,</span><br><span class="line">            fail: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 失败回调</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">switch</span> (shareOption.channel) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'video'</span>:</span><br><span class="line">                options.channel= <span class="string">"video"</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'share'</span>:</span><br><span class="line">                options.desc= desc;</span><br><span class="line">                options.channel= <span class="string">"share"</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> options;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// options中有一个字段 options.channel 来表示该分享是那种方式的分享</span></span><br><span class="line"><span class="comment">// “video” 表示拍抖音视频分享</span></span><br><span class="line"><span class="comment">// “share” 表示普通分享</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抖音中，拍抖音分享需要申请，且分享文案是templateId中指定的文案。 （templateId在小程序后台中申请）</span></span><br><span class="line"><span class="comment">// 头条中，站内分享可以直接指定文案，站外分享依然需要templateId。</span></span><br><span class="line">onShareAppMessage = onShareApp(&#123;</span><br><span class="line">    desc,</span><br><span class="line">    path,</span><br><span class="line">    title,</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Taro中获取节点信息"><a href="#Taro中获取节点信息" class="headerlink" title="Taro中获取节点信息"></a>Taro中获取节点信息</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过useRef</span></span><br><span class="line"><span class="keyword">const</span> dom = useRef(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// &lt;View ref=&#123;dom&#125;&gt;节点&lt;/View&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过useLayoutEffect这个hooks来获取，因为它会在DOM变更之后同步调用，可以用来读取dom布局</span></span><br><span class="line">useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    dom.boundingClientRect().exec(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> &#123;width, height&#125; = res[<span class="number">0</span>];</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过回调函数的形式来获取 */</span></span><br><span class="line"><span class="keyword">const</span> dom = useCallback(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node);</span><br><span class="line">&#125;, []);</span><br><span class="line"> <span class="comment">// &lt;View ref=&#123;dom&#125;&gt;节点&lt;/View&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Taro激励视频的坑"><a href="#Taro激励视频的坑" class="headerlink" title="Taro激励视频的坑"></a>Taro激励视频的坑</h4><p>Android 打开激励视频不走onHide，IOS 打开激励视频走了onHide,<br>当 A页面 跳转（push）到 A页面时，由于页面不会销毁，所以useEffect最后一次执行是不会走return的函数的，<br>这时只能在onHide里面去执行激励视频的 <strong>offClose</strong> 和 <strong>offError</strong> 的监听，但是ios打开激励视频会走onHide，所以导致ios中，看完激励视频<br> <strong>onClose</strong> 和 <strong>onError</strong> 注册的回调函数被 <strong>offClose</strong> 和 <strong>offError</strong> 销毁掉，这时可以在打开激励视频之后，在通过一个变量改变去触发一次useEffect，<br>再走一遍绑定onClose和onError回调方法。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> VIDEO_AD = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 创建激励视频 */</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (VIDEO_AD) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (Taro.createRewardedVideoAd) &#123;</span><br><span class="line">        VIDEO_AD = Taro.createRewardedVideoAd(&#123;</span><br><span class="line">            adUnitId: <span class="string">'kg61k2lrdpa1gbcdom'</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> success_ad = useCallback(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* 看完广告的回调 */</span></span><br><span class="line">&#125;, [ad_id]);</span><br><span class="line"><span class="keyword">const</span> error_ad = useCallback(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* 广告加载错误的回调 */</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 注册回调函数*/</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// if (!ad_id) return;</span></span><br><span class="line">    <span class="keyword">if</span> (VIDEO_AD) &#123;</span><br><span class="line">        VIDEO_AD.onError(error_ad);</span><br><span class="line">        VIDEO_AD.onClose(success_ad);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (VIDEO_AD) &#123;</span><br><span class="line">            VIDEO_AD.offError(error_ad);</span><br><span class="line">            VIDEO_AD.offClose(success_ad);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [ad_id]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a push a，上面的useEffect最后一次return的函数不会执行</span></span><br><span class="line">useDidHide(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (VIDEO_AD) &#123;</span><br><span class="line">        VIDEO_AD.offError(error_ad);</span><br><span class="line">        VIDEO_AD.offClose(success_ad);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在打开激励视频之后，通过改变ad_id这个字段去再一次的执行useEffect。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. A redirectTo A 则可避免这个问题，也不用在useDidHide中注销回调。</span></span><br></pre></td></tr></table></figure><h4 id="小程序-路由api"><a href="#小程序-路由api" class="headerlink" title="小程序 路由api"></a>小程序 路由api</h4><p>redirectTo(option) 方法会导致页面出现白色闪屏</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能JavaScript之加载和执行</title>
      <link href="/2020/03/17/2020-03-18/"/>
      <url>/2020/03/17/2020-03-18/</url>
      
        <content type="html"><![CDATA[<p>因为浏览器的机制，当浏览器解析到script标签的时候，会阻塞进程去下载js代码，并立即执行。</p><p><strong>1、为了加快页面渲染，将script标签添加至</body>之前，当页面渲染完毕之后再去加载js代码。</strong></p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当script添加在head中时，浏览器解析至此会阻塞整个进程，并等待js加载执行，如果js比较大的话，页面会出现长时间的白屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"a.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"b.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"c.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"a.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"b.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"c.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当我们将script标签移至&lt;/body&gt;之前时，页面会先渲染完毕之后再去下载js代码并执行 --&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2、给script标签加上defer属性，该属性会指明本元素的脚本不会修改DOM，因此代码能够安全的延迟执行。</strong></p><p>加了defer属性的script标签会立即下载脚本(并行下载)，在window.onLoad执行之前执行其中的代码。<br>带有defer属性的script标签可以放置在文档的任何位置，文件下载时不会阻塞浏览器的其他进程。</p><p><strong>3、动态脚本元素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    script.src = src;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大部分浏览器支持</span></span><br><span class="line">    script.onload = callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兼容IE</span></span><br><span class="line">    script.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (script.readyState === <span class="string">'loaded'</span> || script.readyState === <span class="string">'complete'</span>) &#123;</span><br><span class="line">            script.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">            callback &amp;&amp; callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件将在元素被添加到页面时开始下载，这种方式加载脚本的优点在于：无论在何时启动下载，文件的下载和执行过程都不会阻塞页面的其他进程。</span></span><br><span class="line"><span class="comment">// 使用动态脚本节点下载文件时，返回的代码通常会立即执行（除了Firefox和Opera，它们会等待此前所有动态脚本节点执行完毕）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态注入的script会在被添加到页面时开始下载，</span></span><br><span class="line">        <span class="comment">// 但是不会阻塞页面其他进程，</span></span><br><span class="line">        <span class="comment">// 返回的代码通常会立即执行。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 页面加载完成(window.onLoad)之前加载的script</span></span><br><span class="line">        <span class="comment">// 会在页面加载完成(window.onLoad)之前执行</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VUE SSR 踩坑合集</title>
      <link href="/2020/03/11/2020-03-11/"/>
      <url>/2020/03/11/2020-03-11/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p></blockquote><a id="more"></a><h1 id="VUE-服务端渲染（SSR）"><a href="#VUE-服务端渲染（SSR）" class="headerlink" title="VUE 服务端渲染（SSR）"></a>VUE 服务端渲染（SSR）</h1><h2 id="SSR-的优劣势"><a href="#SSR-的优劣势" class="headerlink" title="SSR 的优劣势"></a>SSR 的优劣势</h2><h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul><li>便于SEO</li><li>更快的内容到达时间（避免一进应用就是好几秒的菊花图 ~ ~ )</li></ul><h3 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h3><ul><li>开发条件限制（因为需要在服务器端渲染出html，不能使用window、document等浏览器的属性），浏览器特定的代码只能在某些生命周期钩子函数中使用；一些外部扩展库可能还需要特殊处理才能在服务器渲染应用程序中运行</li><li>涉及项目构建和部署的要求更多</li><li>更多的服务器端负载</li></ul><p>简单介绍了一下Vue服务端渲染，那么服务端渲染打包出来的内容究竟长什么样呢？</p><h3 id="Vue-服务端渲染打包结果"><a href="#Vue-服务端渲染打包结果" class="headerlink" title="Vue 服务端渲染打包结果"></a>Vue 服务端渲染打包结果</h3><p>其中包含两个json文件，还有一些js和html文件 <strong>（静态资源，和普通的浏览器渲染模板打包生成的dist内容一样）</strong> 。我们特别留意一下这两个json文件，它们是Vue服务端渲染比较核心的东西。</p><p><img data-src="http://source.mnnuu.cn/websources/blog/2020-03-11/ssr-vue.png" alt="文件结构"></p><p>既然是服务端渲染，那肯定得开一个node服务来渲染html吧。</p><p><img data-src="http://source.mnnuu.cn/websources/blog/2020-03-11/ssr-vue-server.png" alt="node服务"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// server.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> server = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; createBundleRenderer &#125; = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> template = <span class="built_in">require</span>(<span class="string">'fs'</span>).readFileSync(<span class="string">'./dist/index.client.html'</span>, <span class="string">'utf-8'</span>);</span><br><span class="line"><span class="keyword">const</span> serverBundle = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-server-bundle.json'</span>);</span><br><span class="line"><span class="keyword">const</span> clientManifest = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-client-manifest.json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderer = createBundleRenderer(serverBundle, &#123;</span><br><span class="line">    template,</span><br><span class="line">    clientManifest</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.use(express.static(<span class="string">'./dist'</span>));</span><br><span class="line"></span><br><span class="line">server.get(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> context = &#123; </span><br><span class="line">        url: req.url,</span><br><span class="line">        title: <span class="string">'ssr'</span>,</span><br><span class="line">        meta: <span class="string">`&lt;meta name="viewport" content="width=device-width"&gt;`</span> </span><br><span class="line">    &#125;;</span><br><span class="line">    renderer.renderToString(context, (err, html) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> res.status(<span class="number">500</span>).end(<span class="string">'error: '</span> + err.message)</span><br><span class="line">        res.end(html)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过以上打包后的内容，可以有个比较清晰的方向了。<br>开发后完成后通过 <strong>npm run build</strong> 命令基于 <strong>客户端</strong> 和 <strong>服务端</strong> 两端进行打包，生成 <strong>vue-ssr-client-manifest.json</strong> 文件 和 <strong>vue-ssr-server-bundle.json</strong> 文件。然后在server.js中开启一个服务通过 <strong>vue-server-renderer</strong> 模块中的 <strong>createBundleRenderer()</strong> 方法生成一个renderer对象，在每次浏览器对服务器发起请求的时候，通过调用renderer对象的renderToString方法传入json文件和模板生成html字符串，然后发送给浏览器。</p><p>-.-! then 我们围绕这两个json文件来作文章。</p><p> 先来说下背景，，，最近在看Vue SSR相关知识。参考 vue-ssr 官方 例子，vue-hackernews-2.0，<a href="https://github.com/vuejs/vue-hackernews-2.0" target="_blank" rel="noopener">https://github.com/vuejs/vue-hackernews-2.0</a></p><pre><code>都搞定了后，遇到一个刷新页面的问题（我指的是手动刷新浏览器，不是用router程序刷新），因为程序里router有设置 导航守卫 beforeResolve 用于数据预加载使页面呈现效果。但是，刷新页面后，一直没有响应这个导航守卫。路由配置如下：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="string">'/'</span>: &#123;</span><br><span class="line">    viewpath: <span class="string">'views/homepage'</span>,</span><br><span class="line">    name:<span class="string">'default'</span>,</span><br><span class="line">    title:<span class="string">'首页'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'/hero'</span>: &#123;</span><br><span class="line">    viewpath: <span class="string">'views/hero'</span>,</span><br><span class="line">    name:<span class="string">'hero'</span>,</span><br><span class="line">    title:<span class="string">'英雄'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'/tool'</span>: &#123;</span><br><span class="line">    viewpath: <span class="string">'views/tool'</span>,</span><br><span class="line">    name:<span class="string">'tool'</span>,</span><br><span class="line">    title:<span class="string">'装备'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分别对应三个页面，如下：</span></span><br></pre></td></tr></table></figure><p>（tool页面，手动切换时正常显示的。有图是强刷浏览器，没有响应数据）<br>        咱们先不说在页面create或者mounted做处理。  因为应用程序是打算同时支持vue SSR 和 普通 VUE 程序的，兼容代码写法，不像在vue-cli上客户端加一套逻辑。而且，有守卫导航这个好东西，就是解决这个需求的。</p><pre><code>为甚 beforeResolve 没有生效呢？？？我们来看一下 官方例子的写法，entry-client.js文件，</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeupdate'</span>,to);</span><br><span class="line">    <span class="keyword">const</span> &#123; asyncData &#125; = <span class="keyword">this</span>.$options</span><br><span class="line">    <span class="keyword">if</span> (asyncData) &#123;</span><br><span class="line">      asyncData(&#123;</span><br><span class="line">        store: <span class="keyword">this</span>.$store,</span><br><span class="line">        route: to</span><br><span class="line">      &#125;).then(next).catch(next)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; app, router, store &#125; = createApp()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__INITIAL_STATE__) &#123; </span><br><span class="line">  store.replaceState(<span class="built_in">window</span>.__INITIAL_STATE__)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.onReady(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Add router hook for handling asyncData.</span></span><br><span class="line">  <span class="comment">// Doing it after initial route is resolved so that we don't double-fetch</span></span><br><span class="line">  <span class="comment">// the data that we already have. Using router.beforeResolve() so that all</span></span><br><span class="line">  <span class="comment">// async components are resolved.</span></span><br><span class="line"></span><br><span class="line">  router.beforeResolve(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...这里就是我们想要，预取数据的。</span></span><br><span class="line">        <span class="comment">// 注意到，这个beforeResolve守卫，是在route好了之后才设置的，目的是为了防止服务器已经获取的数据，客户端不用二次获取。  然而，在非ssr应用里，，，我们应该是在router.resolve()之前就应该设置这个导航，不能等页面router解析好了才设置。这就是为什么一刷新页面，没有响应，切换页面时正常的原因所在。</span></span><br><span class="line">        <span class="comment">// 解决办法：把resovle移动到ready函数外面。当然，为了ssr的no double-fetch，，，加一个判断即可。简单的，根据 这个变量 window.__INITIAL_STATE__ 存在来判断即可。因为这个变量就是标志是服务器渲染的页面。</span></span><br></pre></td></tr></table></figure><h2 id="onReady"><a href="#onReady" class="headerlink" title="onReady"></a>onReady</h2><p> 在导航完成初始导航时调用</p><h2 id="beforeEach，beforeResolve"><a href="#beforeEach，beforeResolve" class="headerlink" title="beforeEach，beforeResolve"></a>beforeEach，beforeResolve</h2><p>beforeEach    -&gt; 全局前置守卫：当一个导航触发时，全局前置守卫按照创建顺序调用。<br>beforeResolve -&gt; 全局解析守卫，和beforeEach类似，区别是 在导航被确认之前，同时在所有组件内守卫和异步路由被解析之后被调用</p><p>服务端入口文件(server-entry.js)中, 会根据每个页面请求直接将当前路由设置到router中， asyncData 方法是在路由完成初始导航（onReady）后调用的（防止客户端二次获取相同的数据），然后通过当前路由匹配到的所有组件，依次执行每个组件的asyncData方法<br>客户端入口文件(client-entry.js)中，</p><h3 id="不同的入口文件"><a href="#不同的入口文件" class="headerlink" title="不同的入口文件"></a>不同的入口文件</h3>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的自定义事件实现（观察者模式）</title>
      <link href="/2020/03/03/2020-03-03/"/>
      <url>/2020/03/03/2020-03-03/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在Web开发中，观察者模式随处可见。</p></blockquote><p>web程序是一个基于GUI界面的应用，随处可见用户交互。当用户点击了button按钮，需要执行某个方法来响应button的点击事件，那什么时候才能知道用户点击了按钮呢？你知道吗？反正我是不知道…</p><p>既然不知道用户操作的时间，如何让程序继续运行，可以思考一下。如果我们先把将要执行的方法保存下来，等到用户点击的时候，只需要去让对应的方法执行不就行了吗？</p><a id="more"></a><img style="width: 500px;display: block;margin: 0 auto;" data-src="http://source.mnnuu.cn/websources/blog/2020-03-03/1.png" alt=""><br/><p>代码实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> events = &#123;</span><br><span class="line">    eventOb: &#123;&#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        订阅事件并指定方法</span></span><br><span class="line"><span class="comment">        [params.type] 事件名</span></span><br><span class="line"><span class="comment">        [params.fn] 方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    on (type, fn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.eventOb[type]) <span class="keyword">this</span>.eventOb[type] = [];</span><br><span class="line">        <span class="keyword">this</span>.eventOb[type].push(fn);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        取消订阅某个事件</span></span><br><span class="line"><span class="comment">        [params.type] 事件名</span></span><br><span class="line"><span class="comment">        [params.fn] 需要取消订阅的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    off (type, fn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.eventOb[type]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.eventOb[type].findIndex(<span class="function"><span class="params">item</span> =&gt;</span> fn === item);</span><br><span class="line">        index &gt; <span class="number">-1</span> &amp;&amp; <span class="keyword">this</span>.eventOb[type].splice(index, <span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        触发一个事件</span></span><br><span class="line"><span class="comment">        [params.type] 事件名</span></span><br><span class="line"><span class="comment">        [params.payload] 携带的参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    emit (type, payload) &#123;</span><br><span class="line">        <span class="keyword">const</span> arrFn = <span class="keyword">this</span>.eventOb[type];</span><br><span class="line">        <span class="keyword">if</span> (!arrFn || !arrFn.length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (arrFn.length) &#123;</span><br><span class="line">            <span class="keyword">const</span> fn = arrFn.shift();</span><br><span class="line">            fn.call(<span class="keyword">this</span>, payload);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn1 = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count, <span class="string">'我订阅了点击事件, 我要去更新数据'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count, <span class="string">'我订阅了点击事件, 我要执行一个酷炫的动画'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">events.on(<span class="string">'click'</span>, fn1);</span><br><span class="line">events.on(<span class="string">'click'</span>, fn2);</span><br><span class="line">events.emit(<span class="string">'click'</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 10 "我订阅了点击事件, 我要去更新数据"</span></span><br><span class="line"><span class="comment">// 10 "我订阅了点击事件, 我要执行一个酷炫的动画"</span></span><br></pre></td></tr></table></figure><p>这就是一个典型的观察者模式，先将所有要订阅的事件以及对应的方法( <strong>‘click’</strong> 事件和其对应的方法队列 )保存起来，然后在某个特定的时间点通知事件执行队列中的每一个方法。 </p><p>简单举个例，你在追某一部国产马震神剧。但是呢，这部剧比较傲娇，每周不定时的更新，这就让你急切想看到马震画面的心情变得很烦躁。诶，这个时候某个追剧app提醒你了，想要获取一手更新视频，请订阅哦！你露出一丝丝yx，淡定的点开，页面中有很多种订阅方式，</p><ul><li>该剧更新后，请发邮箱通知我。</li><li>该剧更新后，请直接给我弹个app推送。</li><li>该剧更新后，羞羞的画面，不能让女朋友看见。请发送手机短信通知我。</li></ul><p>这里场景中的 <strong>追剧app</strong> 指代-发布方(手动emit <strong>雷剧更新事件</strong>)，而 <strong>你</strong> 向App订阅的 <strong>雷剧更新事件</strong> 和通知方式相当于 <strong>eventOb</strong> 中的订阅事件和订阅事件对应的方法。当 <strong>追剧app</strong> 接收到视频更新的消息后，会 <strong>emit</strong> 也就是触发 <strong>雷剧更新事件</strong>，然后依次执行该事件对应的方法(每个用户订阅时选择的通知方式)</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
