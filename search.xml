<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高性能JavaScript之加载和执行</title>
      <link href="/Blog/2020/03/17/2020-03-18/"/>
      <url>/Blog/2020/03/17/2020-03-18/</url>
      
        <content type="html"><![CDATA[<p>因为浏览器的机制，当浏览器解析到script标签的时候，会阻塞进程去下载js代码，并立即执行。</p><p><strong>1、为了加快页面渲染，将script标签添加至</body>之前，当页面渲染完毕之后再去加载js代码。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当script添加在head中时，浏览器解析至此会阻塞整个进程，并等待js加载执行，如果js比较大的话，页面会出现长时间的白屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"a.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"b.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"c.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"a.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"b.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"c.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当我们将script标签移至&lt;/body&gt;之前时，页面会先渲染完毕之后再去下载js代码并执行 --&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>2、给script标签加上defer属性，该属性会指明本元素的脚本不会修改DOM，因此代码能够安全的延迟执行。</strong></p><p>加了defer属性的script标签会立即下载脚本(并行下载)，在window.onLoad执行之前执行其中的代码。<br>带有defer属性的script标签可以放置在文档的任何位置，文件下载时不会阻塞浏览器的其他进程。</p><p><strong>3、动态脚本元素</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    script.src = src;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大部分浏览器支持</span></span><br><span class="line">    script.onload = callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兼容IE</span></span><br><span class="line">    script.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (script.readyState === <span class="string">'loaded'</span> || script.readyState === <span class="string">'complete'</span>) &#123;</span><br><span class="line">            script.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">            callback &amp;&amp; callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件将在元素被添加到页面时开始下载，这种方式加载脚本的优点在于：无论在何时启动下载，文件的下载和执行过程都不会阻塞页面的其他进程。</span></span><br><span class="line"><span class="comment">// 使用动态脚本节点下载文件时，返回的代码通常会立即执行（除了Firefox和Opera，它们会等待此前所有动态脚本节点执行完毕）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态注入的script会在被添加到页面时开始下载，</span></span><br><span class="line">        <span class="comment">// 但是不会阻塞页面其他进程，</span></span><br><span class="line">        <span class="comment">// 返回的代码通常会立即执行。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 页面加载完成(window.onLoad)之前加载的script</span></span><br><span class="line">        <span class="comment">// 会在页面加载完成(window.onLoad)之前执行</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VUE SSR 踩坑合集</title>
      <link href="/Blog/2020/03/11/2020-03-11/"/>
      <url>/Blog/2020/03/11/2020-03-11/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p></blockquote><a id="more"></a><h1 id="VUE-服务端渲染（SSR）"><a href="#VUE-服务端渲染（SSR）" class="headerlink" title="VUE 服务端渲染（SSR）"></a>VUE 服务端渲染（SSR）</h1><h2 id="SSR-的优劣势"><a href="#SSR-的优劣势" class="headerlink" title="SSR 的优劣势"></a>SSR 的优劣势</h2><h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul><li>便于SEO</li><li>更快的内容到达时间（避免一进应用就是好几秒的菊花图 ~ ~ )</li></ul><h3 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h3><ul><li>开发条件限制（因为需要在服务器端渲染出html，不能使用window、document等浏览器的属性），浏览器特定的代码只能在某些生命周期钩子函数中使用；一些外部扩展库可能还需要特殊处理才能在服务器渲染应用程序中运行</li><li>涉及项目构建和部署的要求更多</li><li>更多的服务器端负载</li></ul><p>简单介绍了一下Vue服务端渲染，那么服务端渲染打包出来的内容究竟长什么样呢？</p><h3 id="Vue-服务端渲染打包结果"><a href="#Vue-服务端渲染打包结果" class="headerlink" title="Vue 服务端渲染打包结果"></a>Vue 服务端渲染打包结果</h3><p>其中包含两个json文件，还有一些js和html文件 <strong>（静态资源，和普通的浏览器渲染模板打包生成的dist内容一样）</strong> 。我们特别留意一下这两个json文件，它们是Vue服务端渲染比较核心的东西。</p><p><img data-src="http://source.mnnuu.cn/websources/blog/2020-03-11/ssr-vue.png" alt="文件结构"></p><p>既然是服务端渲染，那肯定得开一个node服务来渲染html吧。</p><p><img data-src="http://source.mnnuu.cn/websources/blog/2020-03-11/ssr-vue-server.png" alt="node服务"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// server.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> server = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; createBundleRenderer &#125; = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> template = <span class="built_in">require</span>(<span class="string">'fs'</span>).readFileSync(<span class="string">'./dist/index.client.html'</span>, <span class="string">'utf-8'</span>);</span><br><span class="line"><span class="keyword">const</span> serverBundle = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-server-bundle.json'</span>);</span><br><span class="line"><span class="keyword">const</span> clientManifest = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-client-manifest.json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderer = createBundleRenderer(serverBundle, &#123;</span><br><span class="line">    template,</span><br><span class="line">    clientManifest</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.use(express.static(<span class="string">'./dist'</span>));</span><br><span class="line"></span><br><span class="line">server.get(<span class="string">'*'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> context = &#123; </span><br><span class="line">        url: req.url,</span><br><span class="line">        title: <span class="string">'ssr'</span>,</span><br><span class="line">        meta: <span class="string">`&lt;meta name="viewport" content="width=device-width"&gt;`</span> </span><br><span class="line">    &#125;;</span><br><span class="line">    renderer.renderToString(context, (err, html) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> res.status(<span class="number">500</span>).end(<span class="string">'error: '</span> + err.message)</span><br><span class="line">        res.end(html)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过以上打包后的内容，可以有个比较清晰的方向了。<br>开发后完成后通过 <strong>npm run build</strong> 命令基于 <strong>客户端</strong> 和 <strong>服务端</strong> 两端进行打包，生成 <strong>vue-ssr-client-manifest.json</strong> 文件 和 <strong>vue-ssr-server-bundle.json</strong> 文件。然后在server.js中开启一个服务通过 <strong>vue-server-renderer</strong> 模块中的 <strong>createBundleRenderer()</strong> 方法生成一个renderer对象，在每次浏览器对服务器发起请求的时候，通过调用renderer对象的renderToString方法传入json文件和模板生成html字符串，然后发送给浏览器。</p><p>-.-! then 我们围绕这两个json文件来作文章。</p><p> 先来说下背景，，，最近在看Vue SSR相关知识。参考 vue-ssr 官方 例子，vue-hackernews-2.0，<a href="https://github.com/vuejs/vue-hackernews-2.0" target="_blank" rel="noopener">https://github.com/vuejs/vue-hackernews-2.0</a></p><pre><code>都搞定了后，遇到一个刷新页面的问题（我指的是手动刷新浏览器，不是用router程序刷新），因为程序里router有设置 导航守卫 beforeResolve 用于数据预加载使页面呈现效果。但是，刷新页面后，一直没有响应这个导航守卫。路由配置如下：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="string">'/'</span>: &#123;</span><br><span class="line">    viewpath: <span class="string">'views/homepage'</span>,</span><br><span class="line">    name:<span class="string">'default'</span>,</span><br><span class="line">    title:<span class="string">'首页'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'/hero'</span>: &#123;</span><br><span class="line">    viewpath: <span class="string">'views/hero'</span>,</span><br><span class="line">    name:<span class="string">'hero'</span>,</span><br><span class="line">    title:<span class="string">'英雄'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'/tool'</span>: &#123;</span><br><span class="line">    viewpath: <span class="string">'views/tool'</span>,</span><br><span class="line">    name:<span class="string">'tool'</span>,</span><br><span class="line">    title:<span class="string">'装备'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分别对应三个页面，如下：</span></span><br></pre></td></tr></table></figure><p>（tool页面，手动切换时正常显示的。有图是强刷浏览器，没有响应数据）<br>        咱们先不说在页面create或者mounted做处理。  因为应用程序是打算同时支持vue SSR 和 普通 VUE 程序的，兼容代码写法，不像在vue-cli上客户端加一套逻辑。而且，有守卫导航这个好东西，就是解决这个需求的。</p><pre><code>为甚 beforeResolve 没有生效呢？？？我们来看一下 官方例子的写法，entry-client.js文件，</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeupdate'</span>,to);</span><br><span class="line">    <span class="keyword">const</span> &#123; asyncData &#125; = <span class="keyword">this</span>.$options</span><br><span class="line">    <span class="keyword">if</span> (asyncData) &#123;</span><br><span class="line">      asyncData(&#123;</span><br><span class="line">        store: <span class="keyword">this</span>.$store,</span><br><span class="line">        route: to</span><br><span class="line">      &#125;).then(next).catch(next)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; app, router, store &#125; = createApp()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__INITIAL_STATE__) &#123; </span><br><span class="line">  store.replaceState(<span class="built_in">window</span>.__INITIAL_STATE__)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.onReady(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Add router hook for handling asyncData.</span></span><br><span class="line">  <span class="comment">// Doing it after initial route is resolved so that we don't double-fetch</span></span><br><span class="line">  <span class="comment">// the data that we already have. Using router.beforeResolve() so that all</span></span><br><span class="line">  <span class="comment">// async components are resolved.</span></span><br><span class="line"></span><br><span class="line">  router.beforeResolve(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...这里就是我们想要，预取数据的。</span></span><br><span class="line">        <span class="comment">// 注意到，这个beforeResolve守卫，是在route好了之后才设置的，目的是为了防止服务器已经获取的数据，客户端不用二次获取。  然而，在非ssr应用里，，，我们应该是在router.resolve()之前就应该设置这个导航，不能等页面router解析好了才设置。这就是为什么一刷新页面，没有响应，切换页面时正常的原因所在。</span></span><br><span class="line">        <span class="comment">// 解决办法：把resovle移动到ready函数外面。当然，为了ssr的no double-fetch，，，加一个判断即可。简单的，根据 这个变量 window.__INITIAL_STATE__ 存在来判断即可。因为这个变量就是标志是服务器渲染的页面。</span></span><br></pre></td></tr></table></figure><h2 id="onReady"><a href="#onReady" class="headerlink" title="onReady"></a>onReady</h2><p> 在导航完成初始导航时调用</p><h2 id="beforeEach，beforeResolve"><a href="#beforeEach，beforeResolve" class="headerlink" title="beforeEach，beforeResolve"></a>beforeEach，beforeResolve</h2><p>beforeEach    -&gt; 全局前置守卫：当一个导航触发时，全局前置守卫按照创建顺序调用。<br>beforeResolve -&gt; 全局解析守卫，和beforeEach类似，区别是 在导航被确认之前，同时在所有组件内守卫和异步路由被解析之后被调用</p><p>服务端入口文件(server-entry.js)中, 会根据每个页面请求直接将当前路由设置到router中， asyncData 方法是在路由完成初始导航（onReady）后调用的（防止客户端二次获取相同的数据），然后通过当前路由匹配到的所有组件，依次执行每个组件的asyncData方法<br>客户端入口文件(client-entry.js)中，</p><h3 id="不同的入口文件"><a href="#不同的入口文件" class="headerlink" title="不同的入口文件"></a>不同的入口文件</h3>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack环境构建</title>
      <link href="/Blog/2020/03/09/2020-03-09/"/>
      <url>/Blog/2020/03/09/2020-03-09/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章将教会你手动构建项目环境。</p></blockquote><p>前端自动构建工具从nodejs出现开始，逐渐盛行开。带领WEB前端开发走向了一个自动化、工程化的时代。</p><p>目前WEB前端开发的三大框架都有其脚手架，已经帮助我们完成了webpack的配置，可以让我们注重核心代码的开发。如果我们要根据不同的业务需求，自定义配置文件应该怎么做呢？</p><a id="more"></a><p>首先我们要明确webpack帮助我们做了什么！</p><p>在远古的web开发时代</p><p>转换es6 ++<br>转换jsx<br>css前缀补全<br>压缩混淆<br>图片压缩等</p><p>文件指纹:</p><ul><li>Hash: 和整个项目的构架相关，只要项目文件有修改，整个项目构建hash值就会更改；</li><li>Chunkhash: 和webpack打包的chunk相关，不同的entry会生成不同的chunkhash；</li><li>contenthash：根据文件内容来定义hash，文件内容不变，则contenthash不变；</li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的自定义事件实现（观察者模式）</title>
      <link href="/Blog/2020/03/03/2020-03-03/"/>
      <url>/Blog/2020/03/03/2020-03-03/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在Web开发中，观察者模式随处可见。</p></blockquote><p>web程序是一个基于GUI界面的应用，随处可见用户交互。当用户点击了button按钮，需要执行某个方法来响应button的点击事件，那什么时候才能知道用户点击了按钮呢？你知道吗？反正我是不知道…</p><p>既然不知道用户操作的时间，如何让程序继续运行，可以思考一下。如果我们先把将要执行的方法保存下来，等到用户点击的时候，只需要去让对应的方法执行不就行了吗？</p><a id="more"></a><img style="width: 500px;display: block;margin: 0 auto;" data-src="http://source.mnnuu.cn/websources/blog/2020-03-03/1.png" alt=""><br/><p>代码实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> events = &#123;</span><br><span class="line">    eventOb: &#123;&#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        订阅事件并指定方法</span></span><br><span class="line"><span class="comment">        [params.type] 事件名</span></span><br><span class="line"><span class="comment">        [params.fn] 方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    on (type, fn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.eventOb[type]) <span class="keyword">this</span>.eventOb[type] = [];</span><br><span class="line">        <span class="keyword">this</span>.eventOb[type].push(fn);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        取消订阅某个事件</span></span><br><span class="line"><span class="comment">        [params.type] 事件名</span></span><br><span class="line"><span class="comment">        [params.fn] 需要取消订阅的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    off (type, fn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.eventOb[type]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.eventOb[type].findIndex(<span class="function"><span class="params">item</span> =&gt;</span> fn === item);</span><br><span class="line">        index &gt; <span class="number">-1</span> &amp;&amp; <span class="keyword">this</span>.eventOb[type].splice(index, <span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        触发一个事件</span></span><br><span class="line"><span class="comment">        [params.type] 事件名</span></span><br><span class="line"><span class="comment">        [params.payload] 携带的参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    emit (type, payload) &#123;</span><br><span class="line">        <span class="keyword">const</span> arrFn = <span class="keyword">this</span>.eventOb[type];</span><br><span class="line">        <span class="keyword">if</span> (!arrFn || !arrFn.length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (arrFn.length) &#123;</span><br><span class="line">            <span class="keyword">const</span> fn = arrFn.shift();</span><br><span class="line">            fn.call(<span class="keyword">this</span>, payload);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn1 = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count, <span class="string">'我订阅了点击事件, 我要去更新数据'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count, <span class="string">'我订阅了点击事件, 我要执行一个酷炫的动画'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">events.on(<span class="string">'click'</span>, fn1);</span><br><span class="line">events.on(<span class="string">'click'</span>, fn2);</span><br><span class="line">events.emit(<span class="string">'click'</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 10 "我订阅了点击事件, 我要去更新数据"</span></span><br><span class="line"><span class="comment">// 10 "我订阅了点击事件, 我要执行一个酷炫的动画"</span></span><br></pre></td></tr></table></figure><p>这就是一个典型的观察者模式，先将所有要订阅的事件以及对应的方法( <strong>‘click’</strong> 事件和其对应的方法队列 )保存起来，然后在某个特定的时间点通知事件执行队列中的每一个方法。 </p><p>简单举个例，你在追某一部国产马震神剧。但是呢，这部剧比较傲娇，每周不定时的更新，这就让你急切想看到马震画面的心情变得很烦躁。诶，这个时候某个追剧app提醒你了，想要获取一手更新视频，请订阅哦！你露出一丝丝yx，淡定的点开，页面中有很多种订阅方式，</p><ul><li>该剧更新后，请发邮箱通知我。</li><li>该剧更新后，请直接给我弹个app推送。</li><li>该剧更新后，羞羞的画面，不能让女朋友看见。请发送手机短信通知我。</li></ul><p>这里场景中的 <strong>追剧app</strong> 指代-发布方(手动emit <strong>雷剧更新事件</strong>)，而 <strong>你</strong> 向App订阅的 <strong>雷剧更新事件</strong> 和通知方式相当于 <strong>eventOb</strong> 中的订阅事件和订阅事件对应的方法。当 <strong>追剧app</strong> 接收到视频更新的消息后，会 <strong>emit</strong> 也就是触发 <strong>雷剧更新事件</strong>，然后依次执行该事件对应的方法(每个用户订阅时选择的通知方式)</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
