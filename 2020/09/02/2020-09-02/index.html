<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yang.mnnuu.cn","root":"/","scheme":"Mist","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"slideUpBigIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Generator函数是ES6提供的一种异步编程解决方案。">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6 之 Generator函数">
<meta property="og:url" content="yang.mnnuu.cn/2020/09/02/2020-09-02/index.html">
<meta property="og:site_name" content="南豆">
<meta property="og:description" content="Generator函数是ES6提供的一种异步编程解决方案。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://media.prod.mdn.mozit.cloud/attachments/2020/02/23/17124/7cbd04169bbb5be13ede088ff0833882/The_Javascript_Runtime_Environment_Example.svg">
<meta property="article:published_time" content="2020-09-02T01:35:45.000Z">
<meta property="article:modified_time" content="2020-09-03T03:21:34.186Z">
<meta property="article:author" content="南豆">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="es6">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://media.prod.mdn.mozit.cloud/attachments/2020/02/23/17124/7cbd04169bbb5be13ede088ff0833882/The_Javascript_Runtime_Environment_Example.svg">

<link rel="canonical" href="yang.mnnuu.cn/2020/09/02/2020-09-02/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>ES6 之 Generator函数 | 南豆</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">南豆</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">鱼、熊掌不可兼得</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="yang.mnnuu.cn/2020/09/02/2020-09-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="南豆">
      <meta itemprop="description" content="吾日三省吾身">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南豆">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          ES6 之 Generator函数
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-02 09:35:45" itemprop="dateCreated datePublished" datetime="2020-09-02T09:35:45+08:00">2020-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-03 11:21:34" itemprop="dateModified" datetime="2020-09-03T11:21:34+08:00">2020-09-03</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Generator函数是ES6提供的一种异步编程解决方案。</p>
<a id="more"></a>

<h2 id="执行栈与事件队列"><a href="#执行栈与事件队列" class="headerlink" title="执行栈与事件队列"></a>执行栈与事件队列</h2><p>JavaScript是单线程非阻塞的脚本语言，意味着JS代码在执行的时候都是通过一个线程（主线程）来执行。如果都是同步代码，js引擎从上到下依次执行，当遇到比较耗时的操作（I/O、AJAX请求等）时，需要一直等待其执行完毕才能继续向下执行。这就会造成阻塞，UI界面将会一直卡着不动，不能进行更多的操作，这将是一种很糟糕的体验。为了解决阻塞的问题，JS引擎引入了<strong>异步队列</strong>的概念。</p>
<p>JS引擎执行代码的时候，会通过一个<strong>执行栈</strong>来管理各个<strong>执行上下文</strong>。在一个脚本执行的时候，如果是函数，则会创建该函数的执行上下文环境（<strong>在创建阶段会生成活动对象VO、创建作用域链、确定this指向。执行阶段，VO 激活变为 AO （VO + function params + arguments），这时候就可以访问其作用域链</strong>），然后将这个<strong>执行上下文</strong>压入执行栈中，并进入这个<strong>执行上下文环境</strong>执行其中的代码，执行过程中如果再次遇到函数则会重复刚刚的操作。当这个执行环境中的代码执行完毕并返回结果后，js会退出这个执行上下文环境并将其销毁，回到上一个执行上下文环境中。这个过程将会反复进行，直到执行栈中的代码全部执行。</p>
<p>以上的过程说的都是同步代码，那么当一个异步代码执行后会发生啥？再一次申明js是非阻塞的，实现这一点的关键在于 <strong>事件队列</strong></p>
<p>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务，当一个异步事件返回结果之后，js引擎会将这个事件push到一个事件队列中，事件队列中的任务并不会立即执行，而是会等到执行栈中的任务执行完毕（处于闲置状态时），主线程会去查找事件队列是否有任务，如果有，那么主线程会从中取出第一个事件，加入到执行栈中执行，如此反复就形成了一个无限循环，这也是浏览器的<strong>事件循环机制</strong></p>
<p><img data-src="https://media.prod.mdn.mozit.cloud/attachments/2020/02/23/17124/7cbd04169bbb5be13ede088ff0833882/The_Javascript_Runtime_Environment_Example.svg" alt=""></p>
<hr>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>所谓的异步编程，通俗来讲就是先执行一段代码，这段代码我不知道什么时候能够执行完，那么我给它一个方法，这个方法会在它执行完后被调用。</p>
<p><strong>常用的异步编程方式</strong></p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise对象</li>
</ul>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>JavasScript语言对异步编程的实现，就是通过回调函数来实现的，所谓的回调函数就是把任务第二段单独写在一个函数内，等到重新执行这个任务的时候，调用这个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line">fs.readFile(path, <span class="string">'utf-8'</span>, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过传入一个callback函数，去接收readFile执行完毕过后的参数，然后执行。</span></span><br></pre></td></tr></table></figure>

<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">e</span>) </span>&#123;<span class="built_in">console</span>.log(e)&#125;</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也是通过回调函数在触发过后来执行相应的逻辑</span></span><br></pre></td></tr></table></figure>

<h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!q.includes(callback)) q.push(callback)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emitEvent</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = q.shift();</span><br><span class="line">    fn.call(<span class="literal">null</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addEvent(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'触发了什么事件'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某个地方触发了事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">emitEvent(&#123;&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>回调函数本身并没有什么问题，它的问题出现在多个回调嵌套。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(file_a, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  fs.readFile(file_b, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以想象一下，当出现多重嵌套的时候。代码和逻辑会乱做一团，因为多个异步操作嵌套形成了强耦合，这种情况被称为<strong>“回调地狱”</strong></p>
<p>Promise就是解决这个问题而被提出来的，它不是新的语法，而是回调函数的另一种实现方式，可以将多重嵌套用链式调用的方式来运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设readFile已被Promise化</span></span><br><span class="line">readFile(file_a)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> readFile(file_b))</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> readFile(file_c))</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'读取完毕'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到，使用Promise化的readFile执行过程更加清楚。那么除了Promise有没有更好的方式来实现异步编程呢？</p>
<p>有的。</p>
<h2 id="Generator生成器"><a href="#Generator生成器" class="headerlink" title="Generator生成器"></a>Generator生成器</h2><p>一个简单的生成器的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>  <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span>  <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line">g.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: 2, dong: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>generator在调用的时候并不会立即执行，而是返回一个指向内部状态的指针对象（遍历器对象），必须调用遍历器对象的next方法，使指针移向下一个状态，直到遇到yield表达式或者return为止。<strong>yield表达式可以理解为一个暂停标志，只有在调用遍历器对象的next方法才能恢复执行</strong>。</p>
<p>next方法返回一个对象，包含两个属性。一个是<strong>value</strong>属性，对应当前yield表达式对应的值，另一个是<strong>done</strong>属性，表示当前遍历是否结束。</p>
<p>generator函数还可通过next方法传值到生成器内部。<strong>yield</strong>表达式自身并没有返回值，也可以说是总是<strong>返回的undefined</strong>，next方法可以传入一个参数，<strong>这个参数就会被当做上一个yield表达式的返回值</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> a1 = <span class="keyword">yield</span> <span class="string">'A'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(a1, <span class="string">'a1'</span>);</span><br><span class="line">    <span class="keyword">let</span> a2 = <span class="keyword">yield</span> <span class="string">'B'</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">console</span>.log(a2, <span class="string">'a2'</span>);</span><br><span class="line">    <span class="keyword">let</span> a3 = <span class="keyword">yield</span> <span class="string">'C'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(a3, <span class="string">'a3'</span>);</span><br><span class="line">    <span class="keyword">let</span> a4 = <span class="keyword">yield</span> <span class="string">'D'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(a4, <span class="string">'a4'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next(<span class="number">1</span>);           <span class="comment">// &#123;value: A, done: false&#125;</span></span><br><span class="line">            <span class="comment">// 执行到 yield 'A' 的时候暂停执行，</span></span><br><span class="line">            <span class="comment">// 此时传入的 “1”，由于是上一个yield表达式的返回值，</span></span><br><span class="line">            <span class="comment">// 所以在第一次使用next方法时，传递参数是无效的。</span></span><br><span class="line">            <span class="comment">// V8引擎会直接忽略第一次next方法的参数。</span></span><br><span class="line">                </span><br><span class="line">g.next(<span class="number">2</span>); <span class="comment">// 2 a1      &#123;value: B, done: false&#125;</span></span><br><span class="line">g.next(<span class="number">3</span>); <span class="comment">// 3 a2      &#123;value: C, done: false&#125;</span></span><br><span class="line">g.next(<span class="number">4</span>); <span class="comment">// 4 a3      &#123;value: D, done: false&#125;</span></span><br><span class="line">g.next(<span class="number">5</span>); <span class="comment">// 5 a4      &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果想要第一次调用next方法就能够传入值，可以在generator函数外包一层</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapper</span> (<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> g = gen(...args);</span><br><span class="line">      <span class="keyword">let</span> r = g.next();</span><br><span class="line">      <span class="built_in">console</span>.log(r, <span class="string">'第一次执行next的返回值'</span>);</span><br><span class="line">      <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w = wrapper(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> r = <span class="keyword">yield</span> <span class="number">123</span>; <span class="comment">// 在包装函数返回的函数内部执行第一个 next 方法。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'firstInput:'</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'DONE'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">w().next(<span class="string">'test'</span>); <span class="comment">// 123, 第一次执行next的返回值</span></span><br><span class="line">                  <span class="comment">// firstInout: test</span></span><br></pre></td></tr></table></figure>

<p>利用生成器generator这一特性（遇到yield表达式会暂停执行，next方法可以传入参数作为上一个yield表达式的返回值），结合回调函数来看看下面的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(path, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> readFile(<span class="string">'./package.json'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> result2 = <span class="keyword">yield</span> readFile(<span class="string">'./README.md'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行该函数并注册一个回调方法。</span></span><br><span class="line">g.next().value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  g.next().value的值是readFile执行后返回的一个函数</span></span><br><span class="line"><span class="comment">  function(callback) &#123;</span></span><br><span class="line"><span class="comment">     fs.readFile(path, 'utf-8', callback);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>执行r.value方法会去读取文件，并将传入的callback作为fs.readFile的回调函数</strong>。等到文件读取完毕之后，才会执行这个回调函数。思考一下，那么我们要如何在generator函数中同步获取到文件的内容呢？</p>
<p>我们知道了next方法传入的参数可以作为上一个yield表达式的返回值，那么我们只要通过下一个next方法把结果传入进去不就行了吗！！！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// result 就能就收到data啦</span></span><br><span class="line">    g.next(data).value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        g.next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个时候就能在gen函数中愉快的拿到文件内容，并同步执行了。</p>
<p>写到这，可以思考一下，如果generator函数中有多个异步方法要同步执行，还得自己去调用next().value(…)来执行，这种嵌套比回调地狱还恶心。而且上面的逻辑都是相同的，我们何不写一个方法来自动递归执行呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">let</span> gen = fn();</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">let</span> result = gen.next(data);</span><br><span class="line">         <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">         result.value(next);</span><br><span class="line">     &#125;</span><br><span class="line">     next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> r1 = <span class="keyword">yield</span> readFile(<span class="string">'./package.json'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r1.length);</span><br><span class="line">  <span class="keyword">let</span> r2 = <span class="keyword">yield</span> readFile(<span class="string">'./package.json'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r2.length)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果yield表达式右边是一个Promise呢？实现一个基于Promise的自动执行的generator生成器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span> (<span class="params">interval</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(interval);</span><br><span class="line">        &#125;, interval);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> gen = fn();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = gen.next(data);</span><br><span class="line">    <span class="keyword">if</span>(res.done) <span class="keyword">return</span> res.value;</span><br><span class="line">    res.value.then(<span class="function">(<span class="params">data</span>) =&gt;</span> next(data));</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> i1 = <span class="keyword">yield</span> delay(<span class="number">1000</span>); <span class="comment">// 时隔1s，将interval赋值给i1</span></span><br><span class="line">  <span class="built_in">console</span>.log(i1);</span><br><span class="line">  <span class="keyword">const</span> i2 = <span class="keyword">yield</span> delay(<span class="number">2000</span>); <span class="comment">// 再次时隔2s， 将interval赋值给I2</span></span><br><span class="line">  <span class="built_in">console</span>.log(i2);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这也是ES7中async/await的核心原理，async/await就是一个自动执行的生成器的语法糖，async可以理解为 function 后面的 “*”，await可以理解成yield表达式。<br>async/await在语义更加清晰。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/javascript/" rel="tag"># javascript</a>
              <a href="/tags/es6/" rel="tag"># es6</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/08/18/2020-08-18/" rel="next" title="COCOS CREATOR 使用时候遇到的问题">
      COCOS CREATOR 使用时候遇到的问题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#执行栈与事件队列"><span class="nav-number">1.</span> <span class="nav-text">执行栈与事件队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步编程"><span class="nav-number">2.</span> <span class="nav-text">异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回调函数"><span class="nav-number">2.1.</span> <span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件监听"><span class="nav-number">2.2.</span> <span class="nav-text">事件监听</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发布-订阅"><span class="nav-number">2.3.</span> <span class="nav-text">发布&#x2F;订阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise"><span class="nav-number">2.4.</span> <span class="nav-text">Promise</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generator生成器"><span class="nav-number">3.</span> <span class="nav-text">Generator生成器</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="南豆"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">南豆</p>
  <div class="site-description" itemprop="description">吾日三省吾身</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/sunYEAN" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sunYEAN" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:741751004@qq.com" title="E-Mail → mailto:741751004@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南豆</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '0e5c62280381364ee55b',
      clientSecret: 'cf2997799193e9fb1ebc4b8130aa2f78c4a41508',
      repo        : 'blog-comments',
      owner       : 'sunYEAN',
      admin       : ['sunYEAN'],
      id          : '3ae8a42a6a45380bc1f71859baf06a92',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
